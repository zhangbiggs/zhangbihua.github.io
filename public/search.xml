<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[工厂模式(Factory)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FFactory%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 简单工厂模式的要点 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。 简单工厂模式包含三个角色： 工厂角色负责实现创建所有实例的内部逻辑； 抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口； 具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。 ES5实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465function Factory() &#123; this.createEmployee = function (type) &#123; var employee; if (type === "fulltime") &#123; employee = new FullTime(); &#125; else if (type === "parttime") &#123; employee = new PartTime(); &#125; else if (type === "temporary") &#123; employee = new Temporary(); &#125; else if (type === "contractor") &#123; employee = new Contractor(); &#125; employee.type = type; employee.say = function () &#123; log.add(this.type + ": rate " + this.hourly + "/hour"); &#125; return employee; &#125;&#125; var FullTime = function () &#123; this.hourly = "$12";&#125;; var PartTime = function () &#123; this.hourly = "$11";&#125;; var Temporary = function () &#123; this.hourly = "$10";&#125;; var Contractor = function () &#123; this.hourly = "$15";&#125;; // log helpervar log = (function () &#123; var log = ""; return &#123; add: function (msg) &#123; log += msg + "\n"; &#125;, show: function () &#123; alert(log); log = ""; &#125; &#125;&#125;)(); function run() &#123; var employees = []; var factory = new Factory(); employees.push(factory.createEmployee("fulltime")); employees.push(factory.createEmployee("parttime")); employees.push(factory.createEmployee("temporary")); employees.push(factory.createEmployee("contractor")); for (var i = 0, len = employees.length; i &lt; len; i++) &#123; employees[i].say(); &#125; log.show();&#125; ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243class Product &#123; constructor() &#123; console.log('Product Class created'); &#125;&#125;class ConcreteProduct extends Product &#123; constructor() &#123; super(); console.log('ConcreteProduct Class created'); &#125;&#125;class Creator &#123; constructor() &#123; console.log('Creator Class created'); &#125; factoryMethod() &#123; console.log('Creator.factoryMethod created'); &#125; anOperation() &#123; console.log('Creator.anOperation created'); this.product = this.factoryMethod(); console.log(this.product instanceof ConcreteProduct); &#125;&#125;class ConcreteCreator extends Creator &#123; constructor() &#123; super(); console.log('ConcreteCreator Class created'); &#125; factoryMethod() &#123; return new ConcreteProduct(); &#125;&#125;var factory = new ConcreteCreator();factory.anOperation(); Typescript实现12345678910111213141516171819202122232425262728293031namespace FactoryMethodPattern &#123; export interface AbstractProduct &#123; method(param?: any) : void; &#125; export class ConcreteProductA implements AbstractProduct &#123; method = (param?: any) =&gt; &#123; return "Method of ConcreteProductA"; &#125; &#125; export class ConcreteProductB implements AbstractProduct &#123; method = (param?: any) =&gt; &#123; return "Method of ConcreteProductB"; &#125; &#125; export class ProductFactory &#123; public static createProduct(type: string) : AbstractProduct &#123; if (type === "A") &#123; return new ConcreteProductA(); &#125; else if (type === "B") &#123; return new ConcreteProductB(); &#125; return null; &#125; &#125;&#125; 参考以下内容: 图说设计模式 JavaScript Design Patterns ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式(Singleton)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FSingleton%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 单例模式的要点有三个：- 一是某个类只能有一个实例； - 二是它必须自行创建这个实例； - 三是它必须自行向整个系统提供这个实例。 在单例模式的实现过程中，需要注意如下三点：- 单例类的构造函数为私有； - 提供一个自身的静态私有成员变量； - 提供一个公有的静态工厂方法。 ES5实现123456789101112131415161718192021222324var Singleton = (function () &#123; var instance; function createInstance() &#123; var object = new Object("I am the instance"); return object; &#125; return &#123; getInstance: function () &#123; if (!instance) &#123; instance = createInstance(); &#125; return instance; &#125; &#125;;&#125;)(); var instance1 = Singleton.getInstance();var instance2 = Singleton.getInstance();let ob1 = new Singleton.getInstance();let ob2 = new Singleton.getInstance();console.log(ob1 === ob2); ES6实现1234567891011121314class Singleton &#123; constructor(data) &#123; if (Singleton.prototype.Instance === undefined) &#123; this.data = data; Singleton.prototype.Instance = this; &#125; return Singleton.prototype.Instance; &#125;&#125;let ob1 = new Singleton.getInstance();let ob2 = new Singleton("two");console.log(ob1 === ob2); Typescript实现12345678910111213141516class Singleton &#123; private static instance: Singleton; constructor() &#123;&#125; static get Instance() &#123; if (this.instance === null || this.instance === undefined) &#123; this.instance = new Singleton(); &#125; return this.instance; &#125;&#125;let ob1 = new Singleton("one");let ob2 = new Singleton("two");console.log(ob1 === ob2); 参考以下内容: 图说设计模式 JavaScript Design Patterns ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
</search>