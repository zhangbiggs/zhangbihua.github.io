<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[中介模式(Mediator)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FMediator%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 中介模式的定义 中介者模式用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信； 在具体同事类中实现了在抽象同事类中定义的方法。 中介者模式又称为调停者模式，它是一种对象行为型模式。中介模式包含二个角色： Mediator-抽象中介者用于定义一个接口，该接口用于与各同事对象之间的通信； ConcreteMediator-具体中介者是抽象中介者的子类，通过协调各个同事对象来实现协作行为，了解并维护它的各个同事对象的引用； Colleague-抽象同事类定义各同事的公有方法； Colleague-具体同事类是抽象同事类的子类，每一个同事对象都引用一个中介者对象； ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class Mediator &#123; constructor() &#123; console.log('Mediator Class created'); &#125; colleagueChanged(colleague) &#123; console.log('Mediator.colleagueChanged invoked'); &#125;&#125;class ConcreteMediator extends Mediator &#123; constructor() &#123; super(); console.log('ConcreteMediator Class created'); this.colleague1 = new ConcreteColleague1(this); this.colleague2 = new ConcreteColleague2(this); &#125; colleagueChanged(colleague) &#123; console.log('ConcreteMediator.colleagueChanged invoked'); switch (colleague) &#123; case this.colleague1: console.log('ConcreteColleague1 has Changed -&gt; change ConcreteColleague2.feature: '); this.colleague2.setFeature('new feature 2'); break case this.colleague2: console.log('ConcreteColleague2 has Changed, but do nothing'); break default: console.log('Do nothing'); &#125; &#125;&#125;class Colleague &#123; constructor() &#123; console.log('Colleague Class created'); &#125; changed() &#123; console.log('Colleague.changed invoked'); this.mediator.colleagueChanged(this); &#125;&#125;class ConcreteColleague1 extends Colleague &#123; constructor(mediator) &#123; super(); console.log('ConcreteColleague1 Class created'); this.mediator = mediator; this.feature = "feature 1"; &#125; setFeature(feature) &#123; console.log('ConcreteColleague1.setFeature invoked'); console.log('ConcreteColleague1 Feature has changed from ' + this.feature + ' to ' + feature) this.feature = feature; this.changed(); &#125;&#125;class ConcreteColleague2 extends Colleague &#123; constructor(mediator) &#123; super(); console.log('ConcreteColleague2 Class created'); this.mediator = mediator; this.feature = "feature 2"; &#125; setFeature(feature) &#123; console.log('ConcreteColleague2.setFeature invoked'); console.log('ConcreteColleague2 Feature has changed from ' + this.feature + ' to ' + feature); this.feature = feature; this.changed(); &#125;&#125;var mediator = new ConcreteMediator();mediator.colleague1.setFeature("new feature 1"); Typescript实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162namespace MediatorPattern &#123; export interface Mediator &#123; send(msg: string, colleague: Colleague): void; &#125; export class Colleague &#123; public mediator: Mediator; constructor(mediator: Mediator) &#123; this.mediator = mediator; &#125; public send(msg: string): void &#123; throw new Error("Abstract Method!"); &#125; public receive(msg: string): void &#123; throw new Error("Abstract Method!"); &#125; &#125; export class ConcreteColleagueA extends Colleague &#123; constructor(mediator: Mediator) &#123; super(mediator); &#125; public send(msg: string): void &#123; this.mediator.send(msg, this); &#125; public receive(msg: string): void &#123; console.log(msg, "`receive` of ConcreteColleagueA is being called!"); &#125; &#125; export class ConcreteColleagueB extends Colleague &#123; constructor(mediator: Mediator) &#123; super(mediator); &#125; public send(msg: string): void &#123; this.mediator.send(msg, this); &#125; public receive(msg: string): void &#123; console.log(msg, "`receive` of ConcreteColleagueB is being called!"); &#125; &#125; export class ConcreteMediator implements Mediator &#123; public concreteColleagueA: ConcreteColleagueA; public concreteColleagueB: ConcreteColleagueB; public send(msg: string, colleague: Colleague): void &#123; if (this.concreteColleagueA === colleague) &#123; this.concreteColleagueB.receive(msg); &#125; else &#123; this.concreteColleagueA.receive(msg); &#125; &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Behavioral Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>中介模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式(Adapter)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FAdapter%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 适配器模式的定义 适配器模式：用于将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 适配器模式包含四个角色： Target：目标抽象类-定义客户要用的特定领域的接口 Adapter：适配器类-作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心 Adaptee：适配者类-定义了一个已经存在的接口，这个接口需要适配 Client：客户类-在客户类中针对目标抽象类（Target）进行编程，调用在目标抽象类中定义的业务方法 ES6实现1234567891011121314151617181920212223242526272829303132333435363738394041424344class Target &#123; constructor(type) &#123; console.log('Target Class created!'); let result = undefined; switch (type) &#123; case 'adapter': result = new AdapterImpl(); break default: result = undefined; &#125; return result; &#125; request() &#123; console.log('Target.request invoked'); &#125;&#125;class Adapter &#123; constructor() &#123; console.log('Adapter Class created'); &#125; specificRequest() &#123; console.log('Adapter.specificRequest invoked'); &#125;&#125;class AdapterImpl extends Adapter &#123; constructor() &#123; super() console.log('AdapterImpl Class created'); &#125; request() &#123; console.log('AdapterImpl.request invoked'); return this.specificRequest(); &#125;&#125;var f = new Target("adapter");f.request(); Typescript实现12345678910111213141516171819namespace AdapterPattern &#123; export class Adaptee &#123; public method(): void &#123; console.log("`method` of Adaptee is being called"); &#125; &#125; export interface Target &#123; call(): void; &#125; export class Adapter implements Target &#123; public call(): void &#123; console.log("Adapter's `call` method is being called"); var adaptee: Adaptee = new Adaptee(); adaptee.method(); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Structural Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桥接模式(Bridge)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FBridge%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 桥接模式的定义 桥接模式：模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。 桥接模式包含四个角色： Abstraction-抽象类中定义了一个实现类接口类型的对象并可以维护该对象； RefinedAbstraction-扩充抽象类扩充由抽象类定义的接口，它实现了在抽象类中定义的抽象业务方法，在扩充抽象类中可以调用在实现类接口中定义的业务方法； Implementor实现类接口定义了实现类的接口，实现类接口仅提供基本操作，而抽象类定义的接口可能会做更多更复杂的操作； ConcreteImplementor具体实现类实现了实现类接口并且具体实现它，在不同的具体实现类中提供基本操作的不同实现，在程序运行时，具体实现类对象将替换其父类对象，提供给客户端具体的业务操作方法。 ES6实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Abstraction &#123; constructor() &#123; console.log('Abstraction Class created'); &#125; operation() &#123; console.log('Abstraction.operation invoked'); this.imp.operationImp(); &#125;&#125;class RefinedAbstraction extends Abstraction &#123; constructor() &#123; super() console.log('RefinedAbstraction Class created'); &#125; setImp(imp) &#123; console.log('RefinedAbstraction.setImp invoked'); this.imp = imp &#125;&#125;class Implementor &#123; constructor() &#123; console.log('Implementor Class created'); &#125; operationImp() &#123; console.log('Implementor.operationImp invoked'); &#125;&#125;class ConcreteImplementorA extends Implementor &#123; constructor() &#123; super() console.log('ConcreteImplementorA Class created'); &#125; operationImp() &#123; console.log('ConcreteImplementorA.operationImp invoked'); &#125;&#125;class ConcreteImplementorB extends Implementor &#123; constructor() &#123; super() console.log('ConcreteImplementorB Class created'); &#125; operationImp() &#123; console.log('ConcreteImplementorB.operationImp invoked'); &#125;&#125;var abstraction = new RefinedAbstraction();abstraction.setImp(new ConcreteImplementorA());abstraction.operation();abstraction.setImp(new ConcreteImplementorB());abstraction.operation(); Typescript实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Abstraction &#123; constructor() &#123; console.log('Abstraction Class created'); &#125; operation() &#123; console.log('Abstraction.operation invoked'); this.imp.operationImp(); &#125;&#125;class RefinedAbstraction extends Abstraction &#123; constructor() &#123; super() console.log('RefinedAbstraction Class created'); &#125; setImp(imp) &#123; console.log('RefinedAbstraction.setImp invoked'); this.imp = imp &#125;&#125;class Implementor &#123; constructor() &#123; console.log('Implementor Class created'); &#125; operationImp() &#123; console.log('Implementor.operationImp invoked'); &#125;&#125;class ConcreteImplementorA extends Implementor &#123; constructor() &#123; super() console.log('ConcreteImplementorA Class created'); &#125; operationImp() &#123; console.log('ConcreteImplementorA.operationImp invoked'); &#125;&#125;class ConcreteImplementorB extends Implementor &#123; constructor() &#123; super() console.log('ConcreteImplementorB Class created'); &#125; operationImp() &#123; console.log('ConcreteImplementorB.operationImp invoked'); &#125;&#125;var abstraction = new RefinedAbstraction();abstraction.setImp(new ConcreteImplementorA());abstraction.operation();abstraction.setImp(new ConcreteImplementorB());abstraction.operation(); 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Structural Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>桥接模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合模式(Composite)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FComposite%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 ES6实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Component &#123; constructor() &#123; console.log('Component Class created'); &#125; operation() &#123; console.log('Component.operation invoked'); &#125; add(Component) &#123; console.log('Component.add invoked'); &#125; remove(Component) &#123; console.log('Component.remove invoked'); &#125; getChild(key) &#123; console.log('Component.getChild invoked'); &#125;&#125;class Leaf extends Component &#123; constructor(name) &#123; super(); this.name = name; console.log('Leaf Class created'); &#125; operation() &#123; console.log('Leaf.operation invoked'); console.log(this.name); &#125;&#125;class Composite extends Component &#123; constructor(name) &#123; super(); this.name = name; this.children = []; console.log('Composite Class created'); &#125; operation() &#123; console.log('Composite operation for: ' + this.name) for (var i in this.children) &#123; this.children[i].operation(); &#125; &#125; add(Component) &#123; console.log('Composite.add invoked'); this.children.push(Component); &#125; remove(Component) &#123; console.log('Composite.remove invoked'); for (var i in this.children) &#123; if (this.children[i] === Component) &#123; this.children.splice(i, 1); &#125; &#125; &#125; getChild(key) &#123; console.log('Composite.getChild invoked'); return this.children[key]; &#125;&#125;var composite1 = new Composite('C1');composite1.add(new Leaf('L1'));composite1.add(new Leaf('L2'));var composite2 = new Composite('C2');composite2.add(composite1);composite1.getChild(1).operation();composite2.operation(); Typescript实现1234567891011121314151617181920212223242526272829303132333435363738394041424344namespace CompositePattern &#123; export interface Component &#123; operation(): void; &#125; export class Composite implements Component &#123; private list: Component[]; private s: String; constructor(s: String) &#123; this.list = []; this.s = s; &#125; public operation(): void &#123; console.log("`operation of `", this.s) for (var i = 0; i &lt; this.list.length; i += 1) &#123; this.list[i].operation(); &#125; &#125; public add(c: Component): void &#123; this.list.push(c); &#125; public remove(i: number): void &#123; if (this.list.length &lt;= i) &#123; throw new Error("index out of bound!"); &#125; this.list.splice(i, 1); &#125; &#125; export class Leaf implements Component &#123; private s: String; constructor(s: String) &#123; this.s = s; &#125; public operation(): void &#123; console.log("`operation` of Leaf", this.s, " is called."); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Structural Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者模式(Builder)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FBuilder%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 建造者模式包含如下四个角色： Builder-抽象建造者为创建一个产品对象的各个部件指定抽象接口； ConcreteBuilder-具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象； Product-产品角色是被构建的复杂对象，包含多个组成部件； Director-指挥者负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造 建造者模式的结构中引入了一个指挥者类，该类的作用主要有两个： 一方面它隔离了客户与生产过程； 另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。 ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Builder &#123; constructor() &#123; console.log('Builder Class created!'); &#125; buildPart(partName) &#123; console.log('Builder.buildPart invoked!'); &#125;&#125;class ConcreteBuilder extends Builder &#123; constructor() &#123; super(); console.log('ConcreteBuilder Class created!'); &#125; buildPart(partName) &#123; super.buildPart(partName); console.log('ConcreteBuilder.buildPart invoked!'); this.product = new Product(partName); &#125; getResult() &#123; console.log('ConcreteBuilder.getResult invoked!'); return this.product; &#125;&#125;class Product &#123; constructor(material) &#123; console.log("Product class created"); this.data = material &#125;&#125;class Director &#123; constructor() &#123; this.structure = ['Prod1', 'Prod2', 'Prod3']; console.log("Director class created"); &#125; construct() &#123; console.log("Director.Construct created"); for (var prodName in this.structure) &#123; let builder = new ConcreteBuilder(); builder.buildPart(this.structure[prodName]); builder.getResult(); &#125; &#125;&#125;let director = new Director();director.construct(); Typescript实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869namespace BuilderPattern &#123; export class UserBuilder &#123; private name: string; private age: number; private phone: string; private address: string; constructor(name: string) &#123; this.name = name; &#125; get Name() &#123; return this.name; &#125; setAge(value: number): UserBuilder &#123; this.age = value; return this; &#125; get Age() &#123; return this.age; &#125; setPhone(value: string): UserBuilder &#123; this.phone = value; return this; &#125; get Phone() &#123; return this.phone; &#125; setAddress(value: string): UserBuilder &#123; this.address = value; return this; &#125; get Address() &#123; return this.address; &#125; build(): User &#123; return new User(this); &#125; &#125; export class User &#123; private name: string; private age: number; private phone: string; private address: string; constructor(builder: UserBuilder) &#123; this.name = builder.Name; this.age = builder.Age; this.phone = builder.Phone; this.address = builder.Address &#125; get Name() &#123; return this.name; &#125; get Age() &#123; return this.age; &#125; get Phone() &#123; return this.phone; &#125; get Address() &#123; return this.address; &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Creational Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>建造者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令模式(Command)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FCommand%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 命令模式的定义 命令模式：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化； 对请求排队或者记录请求日志，以及支持可撤销的操作。 命令模式是一种对象行为型模式，其别名为动作模式或事务模式。 命令模式包含四个角色： Command-抽象命令类中声明了用于执行请求等方法，通过这些方法可以调用请求接收者的相关操作； ConcreteCommand-具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中； Invoker-调用者即请求的发送者，又称为请求者，它通过命令对象来执行请求； Receiver-接收者执行与请求相关的操作，它具体实现对请求的业务处理。 ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Invoker &#123; constructor() &#123; console.log('Invoker Class created'); &#125; storeCommand(command) &#123; this.command = command; console.log('Invoker.storeCommand invoked'); &#125;&#125;class Command &#123; constructor() &#123; console.log('Command Class created'); &#125; execute() &#123; console.log('Command.execute invoked'); &#125;&#125;class ConcreteCommand extends Command &#123; constructor(receiver, state) &#123; super(); this.receiver = receiver; console.log('ConcreteCommand Class created'); &#125; execute() &#123; console.log('ConcreteCommand.execute invoked'); this.receiver.action(); &#125;&#125;class Receiver &#123; constructor() &#123; console.log('Receiver Class created'); &#125; action() &#123; console.log('Receiver.action invoked'); &#125;&#125;var invoker = new Invoker();var receiver = new Receiver();var command = new ConcreteCommand(receiver);invoker.storeCommand(command);invoker.command.execute(); Typescript实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465namespace CommandPattern &#123; export class Command &#123; public execute(): void &#123; throw new Error("Abstract method!"); &#125; &#125; export class ConcreteCommand1 extends Command &#123; private receiver: Receiver; constructor(receiver: Receiver) &#123; super(); this.receiver = receiver; &#125; public execute(): void &#123; console.log("`execute` method of ConcreteCommand1 is being called!"); this.receiver.action(); &#125; &#125; export class ConcreteCommand2 extends Command &#123; private receiver: Receiver; constructor(receiver: Receiver) &#123; super(); this.receiver = receiver; &#125; public execute(): void &#123; console.log("`execute` method of ConcreteCommand2 is being called!"); this.receiver.action(); &#125; &#125; export class Invoker &#123; private commands: Command[]; constructor() &#123; this.commands = []; &#125; public storeAndExecute(cmd: Command) &#123; this.commands.push(cmd); cmd.execute(); &#125; &#125; export class Receiver &#123; public action(): void &#123; console.log("action is being called!"); &#125; &#125;&#125;(function main() &#123; var receiver: CommandPattern.Receiver = new CommandPattern.Receiver(), command1: CommandPattern.Command = new CommandPattern.ConcreteCommand1(receiver), command2: CommandPattern.Command = new CommandPattern.ConcreteCommand2(receiver), invoker : CommandPattern.Invoker = new CommandPattern.Invoker(); invoker.storeAndExecute(command1); invoker.storeAndExecute(command2);&#125;()); 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Behavioral Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>命令模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[外观模式(Facade)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FFacade%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 外观模式的定义 外观模式：在外观模式中，外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面， 外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。 外观模式包含二个角色： Facade-外观角色是在客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理； SubSystem-在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能 ES6实现12345678910111213141516171819202122class Facade &#123; constructor() &#123; console.log("Facade class created"); &#125; gotoPage(dp) &#123; switch (dp) &#123; case "Facade": console.log("This is the Facade"); break; case "AbstractFactory": console.log("This is the AbstractFactory"); break; default: console.log("nothing to be matched"); &#125; &#125;&#125;let facade = new Facade();facade.gotoPage('Facade');facade.gotoPage('AbstractFactory'); Typescript实现12345678910111213141516171819202122232425262728293031323334353637383940namespace FacadePattern &#123; export class Part1 &#123; public method1(): void &#123; console.log("`method1` of Part1"); &#125; &#125; export class Part2 &#123; public method2(): void &#123; console.log("`method2` of Part2"); &#125; &#125; export class Part3 &#123; public method3(): void &#123; console.log("`method3` of Part3"); &#125; &#125; export class Facade &#123; private part1: Part1 = new Part1(); private part2: Part2 = new Part2(); private part3: Part3 = new Part3(); public operation1(): void &#123; console.log("`operation1` is called ==="); this.part1.method1(); this.part2.method2(); console.log("=========================="); &#125; public operation2(): void &#123; console.log("`operation2` is called ==="); this.part1.method1(); this.part3.method3(); console.log("=========================="); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Structural Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>外观模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰模式(Decorator)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FDecorator%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 装饰模式的定义 装饰模式：装饰模式用于动态地给一个对象增加一些额外的职责，就增加对象功 能来说，装饰模式比生成子类实现更为灵活。它是一种对象结构型模 式。 装饰模式包含四个角色： Component-抽象构件定义了对象的接口，可以给这些对 象动态增加职责（方法）； ConcreteComponent-具体构件定义了具体的构件对象，实现了 在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）； Decorator-抽象装饰类是抽象构件类的子类，用于给具体构件增加职责，但是具 体职责在其子类中实现； ConcreteDecorator-具体装饰类是抽象装饰类的子类，负责向构 件添加新的职责。 ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Component &#123; constructor() &#123; console.log('Component Class created'); &#125; operation() &#123; console.log('Component.operation invoked'); &#125;&#125;class ConcreteComponent extends Component &#123; constructor() &#123; super(); console.log('ConcreteComponent Class created'); &#125; operation() &#123; console.log('ConcreteComponent.operation invoked'); &#125;&#125;class Decorator extends Component &#123; constructor(component) &#123; super(); this.component = component; console.log('Decorator Class created'); &#125; operation() &#123; console.log('Decorator.operation invoked'); this.component.operation() &#125;&#125;class ConcreteDecoratorA extends Decorator &#123; constructor(component, sign) &#123; super(component); this.addedState = sign; console.log('ConcreteDecoratorA Class created'); &#125; operation() &#123; super.operation(); console.log('ConcreteDecoratorA.operation invoked'); console.log(this.addedState) &#125;&#125;class ConcreteDecoratorB extends Decorator &#123; constructor(component, sign) &#123; super(component); this.addedState = sign; console.log('ConcreteDecoratorB Class created'); &#125; operation() &#123; super.operation(); console.log('ConcreteDecoratorB.operation invoked'); console.log(this.addedState + this.addedState + this.addedState + this.addedState + this.addedState); &#125; addedBehavior() &#123; this.operation(); console.log('ConcreteDecoratorB.operation invoked'); &#125;&#125;var component = new ConcreteComponent();var decoratorA = new ConcreteDecoratorA(component, 'decoratorA');var decoratorB = new ConcreteDecoratorB(component, 'decoratorB');console.log('component: ');component.operation();console.log('decoratorA: ');decoratorA.operation();console.log('decoratorB: ');decoratorB.addedBehavior(); Typescript实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748namespace DecoratorPattern &#123; export interface Component &#123; operation(): void; &#125; export class ConcreteComponent implements Component &#123; private s: String; constructor(s: String) &#123; this.s = s; &#125; public operation(): void &#123; console.log("`operation` of ConcreteComponent", this.s, " is being called!"); &#125; &#125; export class Decorator implements Component &#123; private component: Component; private id: Number; constructor(id: Number, component: Component) &#123; this.id = id; this.component = component; &#125; public get Id(): Number &#123; return this.id; &#125; public operation(): void &#123; console.log("`operation` of Decorator", this.id, " is being called!"); this.component.operation(); &#125; &#125; export class ConcreteDecorator extends Decorator &#123; constructor(id: Number, component: Component) &#123; super(id, component); &#125; public operation(): void &#123; super.operation(); console.log("`operation` of ConcreteDecorator", this.Id, " is being called!"); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Structural Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>装饰模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[享元模式(Flyweight)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FFlyweight%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 享元模式的定义 享元模式：享元模式运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用，它是一种对象结构型模式。 享元模式包含四个角色： Flyweight-抽象享元类声明一个接口，通过它可以接受并作用于外部状态； ConcreteFlyweight-具体享元类实现了抽象享元接口，其实例称为享元对象； UnsharedConcreteFlyweight-非共享具体享元是不能被共享的抽象享元类的子类； FlyweightFactory-享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中。 ES6实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class FlyweightFactory &#123; constructor() &#123; this.flyweights = &#123;&#125;; console.log('FlyweightFactory Class created'); &#125; getFlyweight(key) &#123; console.log('FlyweightFactory.getFlyweight invoked'); if (this.flyweights[key]) &#123; return this.flyweights[key]; &#125; else &#123; this.flyweights[key] = new ConcreteFlyweight(key); return this.flyweights[key]; &#125; &#125; createGibberish(keys) &#123; console.log('FlyweightFactory.createGibberish invoked'); return new UnsharedConcreteFlyweight(keys, this); &#125;&#125;class Flyweight &#123; constructor() &#123; console.log('Flyweight Class created'); &#125; operation(extrinsicState) &#123; console.log('Flyweight.operation invoked'); &#125;&#125;class ConcreteFlyweight extends Flyweight &#123; constructor(key) &#123; super(); this.intrinsicState = key; console.log('ConcreteFlyweight Class created'); &#125; operation(extrinsicState) &#123; console.log('ConcreteFlyweight.operation invoked'); return extrinsicState + this.intrinsicState; &#125;&#125;class UnsharedConcreteFlyweight extends Flyweight &#123; constructor(keys, flyweights) &#123; super(); this.flyweights = flyweights; this.keys = keys; console.log('UnsharedConcreteFlyweight Class created'); &#125; operation(extrinsicState) &#123; console.log('UnsharedConcreteFlyweight.operation invoked'); var key, word = ''; for (var i = 0; i &lt; extrinsicState; i++) &#123; key = this.keys[Math.floor(Math.random() * (this.keys.length))]; word = this.flyweights.getFlyweight(key).operation(word); &#125; console.log('UnsharedConcreteFlyweight Operation: '); console.log(word); &#125;&#125;var flyweights = new FlyweightFactory();var gibberish = flyweights.createGibberish(['-', '+', '*']);gibberish.operation(5); Typescript实现123456789101112131415161718192021222324252627282930313233343536373839404142434445namespace FlyweightPattern &#123; export interface Flyweight &#123; operation(s: String): void; &#125; export class ConcreteFlyweight implements Flyweight &#123; private instrinsicState: String; constructor(instrinsicState: String) &#123; this.instrinsicState = instrinsicState; &#125; public operation(s: String): void &#123; console.log("`operation` of ConcreteFlyweight", s, " is being called!"); &#125; &#125; export class UnsharedConcreteFlyweight implements Flyweight &#123; private allState: number; constructor(allState: number) &#123; this.allState = allState; &#125; public operation(s: String): void &#123; console.log("`operation` of UnsharedConcreteFlyweight", s, " is being called!"); &#125; &#125; export class FlyweightFactory &#123; private fliesMap: &#123; [s: string]: Flyweight; &#125; = &lt;any&gt;&#123;&#125;; constructor() &#123; &#125; public getFlyweight(key: string): Flyweight &#123; if (this.fliesMap[key] === undefined || null) &#123; this.fliesMap[key] = new ConcreteFlyweight(key); &#125; return this.fliesMap[key]; &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Structural Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>享元模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解析器模式(Interpreter)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FInterpreter%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 解析器模式的定义 解析器模式：在外观模式中，外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面， 外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。 解析器模式包含二个角色： Interpreter-外观角色是在客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理； SubSystem-在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能 ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class Context &#123; constructor(input) &#123; this.sum = 0; this.list = []; console.log('Context Class created'); &#125; add(eps) &#123; console.log('Context.add invoked'); this.list.push(eps); &#125; getList() &#123; console.log('Context.getList invoked'); return this.list; &#125; getSum() &#123; console.log('Context.getSum invoked'); return this.sum; &#125; setSum(_sum) &#123; this.sum = _sum; console.log('Context.setSum invoked'); &#125;&#125;class AbstractExpression &#123; constructor() &#123; console.log('AbstractExpression Class created'); &#125; interpret(context) &#123; console.log('AbstractExpression.interpret invoked'); &#125;&#125;class PlusExpression extends AbstractExpression &#123; constructor(name) &#123; super(); this.name = name; console.log('PlusExpression Class created'); &#125; interpret(context) &#123; console.log('PlusExpression.interpret invoked'); var sum = context.getSum(); sum++; context.setSum(sum); &#125;&#125;class MinusExpression extends AbstractExpression &#123; constructor() &#123; super(); this.name = '+'; console.log('MinusExpression Class created'); &#125; interpret(context) &#123; console.log('MinusExpression.interpret invoked'); var sum = context.getSum(); sum--; context.setSum(sum) &#125;&#125;var context = new Context();context.setSum(20);context.add(new PlusExpression());context.add(new PlusExpression());context.add(new PlusExpression());context.add(new MinusExpression());context.add(new MinusExpression());var list = context.getList();for (var i = 0; i &lt; list.length; i++) &#123; var expression = list[i]; expression.interpret(context);&#125;console.log("Result：" + context.getSum()); Typescript实现123456789101112131415161718192021namespace InterpreterPattern &#123; export class Context &#123; &#125; export interface AbstractExpression &#123; interpret(context: Context): void; &#125; export class TerminalExpression implements AbstractExpression &#123; public interpret(context: Context): void &#123; console.log("`interpret` method of TerminalExpression is being called!"); &#125; &#125; export class NonterminalExpression implements AbstractExpression &#123; public interpret(context: Context): void &#123; console.log("`interpret` method of NonterminalExpression is being called!"); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Behavioral Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>解析器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器(Iterator)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FIterator%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 ES6实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Iterator &#123; constructor() &#123; console.log('Iterator Class created'); &#125; first() &#123; console.log('Iterator.first invoked'); &#125; next() &#123; console.log('Iterator.next invoked'); &#125; isDone() &#123; console.log('Iterator.isDone invoked'); &#125; currentItem() &#123; console.log('Iterator.currentItem invoked'); &#125;&#125;class ConcreteIterator extends Iterator &#123; constructor(aggregate) &#123; super(); this.index = 0; this.aggregate = aggregate; console.log('ConcreteIterator Class created'); &#125; first() &#123; console.log('ConcreteIterator.first invoked'); return this.aggregate.list[0]; &#125; next() &#123; console.log('ConcreteIterator.next invoked'); this.index += 1; return this.aggregate.list[this.index]; &#125; currentItem() &#123; console.log('ConcreteIterator.currentItem invoked'); return this.aggregate.list[this.index]; &#125;&#125;class Aggregate &#123; constructor() &#123; console.log('Aggregate Class created'); &#125; createIterator() &#123; console.log('Aggregate.CreateIterator invoked'); &#125;&#125;class ConcreteAggregate extends Aggregate &#123; constructor(list) &#123; super(); this.list = list; console.log('ConcreteAggregate Class created'); &#125; createIterator() &#123; console.log('ConcreteAggregate.CreateIterator invoked'); this.iterator = new ConcreteIterator(this); &#125;&#125;var aggregate = new ConcreteAggregate([0, 1, 2, 3, 4, 5, 6, 7]);aggregate.createIterator();console.log(aggregate.iterator.first());console.log(aggregate.iterator.next());console.log(aggregate.iterator.currentItem()); Typescript实现123456789101112131415namespace IteratorPattern &#123; export namespace Demo &#123; export function show() : void &#123; var nArray = [1, 7, 21, 657, 3, 2, 765, 13, 65], numbers: IteratorPattern.Numbers = new IteratorPattern.Numbers(nArray), it: IteratorPattern.ConcreteIterator = &lt;IteratorPattern.ConcreteIterator&gt;numbers.createIterator(); while (it.hasNext()) &#123; console.log(it.next()); &#125; &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Behavioral Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式(Abstract Factory)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FAbstractFactory%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 抽象工厂模式的定义 抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。 抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构 抽象工厂模式包含四个角色： ConcreteFactory-具体工厂实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中； AbstractProduct-抽象产品为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法； AbstractFactory-抽象工厂用于明生成抽象产品的方法； Product-具体产品定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。 抽象工厂模式适用情况包括： 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节； 系统中有多于一个的产品族，而每次只使用其中某一产品族； 属于同一个产品族的产品将在一起使用； 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。 ES6实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495class AbstractFactory &#123; constructor() &#123; console.log("AbstractFactory class created"); &#125; createProductA(product) &#123; console.log("AbstractFactory.createProductA created"); &#125; createProductB(product) &#123; console.log("AbstractFactory.createProductB created"); &#125;&#125;class ConcreteFactory1 extends AbstractFactory &#123; constructor() &#123; super(); console.log("ConcreteFactory1 class created"); &#125; createProductA(product) &#123; console.log('ConcreteFactory1 createProductA'); return new ProductA1(); &#125; createProductB(product) &#123; console.log('ConcreteFactory1 createProductB'); return new ProductB1(); &#125;&#125;class ConcreteFactory2 extends AbstractFactory &#123; constructor() &#123; super(); console.log("ConcreteFactory2 class created"); &#125; createProductA(product) &#123; console.log('ConcreteFactory2 createProductA'); return new ProductA2(); &#125; createProductB(product) &#123; console.log('ConcreteFactory2 createProductB'); return new ProductB2(); &#125;&#125;class AbstractProductA &#123; constructor() &#123; console.log('AbstractProductA class created'); &#125;&#125;class AbstractProductB &#123; constructor() &#123; console.log('AbstractProductB class created'); &#125;&#125;class ProductA1 extends AbstractProductA &#123; constructor() &#123; super(); console.log('ProductA1 class created'); &#125;&#125;class ProductA2 extends AbstractProductA &#123; constructor() &#123; super(); console.log('ProductA2 class created'); &#125;&#125;class ProductB1 extends AbstractProductB &#123; constructor() &#123; super(); console.log('ProductB1 class created'); &#125;&#125;class ProductB2 extends AbstractProductB &#123; constructor() &#123; super(); console.log('ProductB2 class created'); &#125;&#125;var factory1 = new ConcreteFactory1();var productB1 = factory1.createProductB();var productA1 = factory1.createProductA();var factory2 = new ConcreteFactory2();var productA2 = factory2.createProductA();var productB2 = factory2.createProductB(); Typescript实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273namespace AbstractFactoryPattern &#123; export interface AbstractProductA &#123; methodA(): string; &#125; export interface AbstractProductB &#123; methodB(): number; &#125; export interface AbstractFactory &#123; createProductA(param?: any) : AbstractProductA; createProductB() : AbstractProductB; &#125; export class ProductA1 implements AbstractProductA &#123; methodA = () =&gt; &#123; return "This is methodA of ProductA1"; &#125; &#125; export class ProductB1 implements AbstractProductB &#123; methodB = () =&gt; &#123; return 1; &#125; &#125; export class ProductA2 implements AbstractProductA &#123; methodA = () =&gt; &#123; return "This is methodA of ProductA2"; &#125; &#125; export class ProductB2 implements AbstractProductB &#123; methodB = () =&gt; &#123; return 2; &#125; &#125; export class ConcreteFactory1 implements AbstractFactory &#123; createProductA(param?: any) : AbstractProductA &#123; return new ProductA1(); &#125; createProductB(param?: any) : AbstractProductB &#123; return new ProductB1(); &#125; &#125; export class ConcreteFactory2 implements AbstractFactory &#123; createProductA(param?: any) : AbstractProductA &#123; return new ProductA2(); &#125; createProductB(param?: any) : AbstractProductB &#123; return new ProductB2(); &#125; &#125; export class Tester &#123; private abstractProductA: AbstractProductA; private abstractProductB: AbstractProductB; constructor(factory: AbstractFactory) &#123; this.abstractProductA = factory.createProductA(); this.abstractProductB = factory.createProductB(); &#125; public test(): void &#123; console.log(this.abstractProductA.methodA()); console.log(this.abstractProductB.methodB()); &#125; &#125; &#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Creational Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式(Prototype)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FPrototype%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Prototype &#123; constructor(prototype) &#123; console.log("Prototype Class created"); &#125; setFeature(key, val) &#123; this[key] = val &#125; clone() &#123; console.log("Prototype.clone invoked"); &#125;&#125;class ConcretePrototype1 extends Prototype &#123; constructor() &#123; super(); console.log("ConcretePrototype1 created"); this.feature = "feature 1" &#125; clone() &#123; console.log('ConcretePrototype1.clone invoked'); let clone = new ConcretePrototype1(); let keys = Object.keys(this); keys.forEach(k =&gt; clone.setFeature(k, this[k])); console.log("ConcretePrototype1 cloned"); return clone; &#125;&#125;class ConcretePrototype2 extends Prototype &#123; constructor() &#123; super(); console.log("ConcretePrototype2 created"); this.feature = "feature 2" &#125; clone() &#123; console.log('ConcretePrototype2.Clone function'); let clone = new ConcretePrototype2(); let keys = Object.keys(this); keys.forEach(k =&gt; clone.setFeature(k, this[k])); console.log("ConcretePrototype2 cloned"); return clone; &#125;&#125;var proto1 = new ConcretePrototype1();proto1.setFeature('feature', "feature 11");var clone1 = proto1.clone();console.log(clone1.feature);console.log(typeof clone1);console.log(clone1 === proto1);var proto2 = new ConcretePrototype2();proto2.setFeature('feature', "feature 22");var clone2 = proto2.clone();console.log(clone2.feature);console.log(typeof clone2);console.log(clone2 === proto2); Typescript实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455namespace PrototypePattern &#123; export interface Prototype &#123; clone(): Prototype; toString(): string; &#125; export class Concrete1 implements Prototype &#123; clone() : Prototype &#123; return new Concrete1(); &#125; toString(): string &#123; return "This is Concrete1"; &#125; &#125; export class Concrete2 implements Prototype &#123; clone() : Prototype &#123; return new Concrete2(); &#125; toString(): string &#123; return "This is Concrete2"; &#125; &#125; export class Concrete3 implements Prototype &#123; clone() : Prototype &#123; return new Concrete3(); &#125; toString(): string &#123; return "This is Concrete3"; &#125; &#125; export class Builder &#123; private prototypeMap: &#123; [s: string]: Prototype; &#125; = &#123;&#125;; constructor() &#123; this.prototypeMap['c1'] = new Concrete1(); this.prototypeMap['c2'] = new Concrete2(); this.prototypeMap['c3'] = new Concrete3(); &#125; createOne(s: string): Prototype &#123; console.log(s); return this.prototypeMap[s].clone(); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Creational Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式(Observer)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FObserver%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 观察者模式的定义 观察者模式定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。 观察者模式又叫做发布-订阅模式、模型-视图模式、源-监听器模式或从属者模式。 观察者模式是一种对象行为型模式。 观察者模式包含四个角色： Subject-目标又称为主题，它是指被观察的对象； ConcreteSubject-具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知； Observer-观察者将对观察目标的改变做出反应； ConcreteObserver-在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。 ES6实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Subject &#123; constructor() &#123; console.log('Subject Class created'); &#125; attach(observer) &#123; this.observers.push(observer); console.log('Subject.attach invoked'); &#125; dettach(observer) &#123; console.log('Subject.dettach invoked'); for (var i in this.observers) &#123; if (this.observers[i] === observer) &#123; this.observers.splice(i, 1); &#125; &#125; &#125; notify() &#123; console.log('Subject.notify invoked'); for (var i in this.observers) &#123; this.observers[i].update(this); &#125; &#125;&#125;class ConcreteSubject extends Subject &#123; constructor() &#123; super(); this.subjectState = null; this.observers = []; console.log('ConcreteSubject Class created'); &#125; getState() &#123; console.log('ConcreteSubject.getState invoked'); return this.subjectState; &#125; setState(state) &#123; console.log('ConcreteSubject.setState invoked'); this.subjectState = state; this.notify(); &#125;&#125;class Observer &#123; constructor() &#123; console.log('Observer Class created'); &#125; update() &#123; console.log('Observer.update invoked'); &#125;&#125;class ConcreteObserver extends Observer &#123; constructor() &#123; super(); this.observerState = ''; console.log('ConcreteObserver Class created'); &#125; update(Subject) &#123; console.log('ConcreteObserver.update invoked'); this.observerState = Subject.getState(); console.log('Observer new state: ' + this.observerState); &#125;&#125;var observer1 = new ConcreteObserver();var observer2 = new ConcreteObserver();var subject = new ConcreteSubject();subject.attach(observer1);subject.attach(observer2);subject.setState('state 1'); Typescript实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071namespace ObserverPattern &#123; export class Subject &#123; private observers: Observer[] = []; public register(observer: Observer): void &#123; console.log(observer, "is pushed!"); this.observers.push(observer); &#125; public unregister(observer: Observer): void &#123; var n: number = this.observers.indexOf(observer); console.log(observer, "is removed"); this.observers.splice(n, 1); &#125; public notify(): void &#123; console.log("notify all the observers", this.observers); var i: number , max: number; for (i = 0, max = this.observers.length; i &lt; max; i += 1) &#123; this.observers[i].notify(); &#125; &#125; &#125; export class ConcreteSubject extends Subject &#123; private subjectState: number; get SubjectState(): number &#123; return this.subjectState; &#125; set SubjectState(subjectState: number) &#123; this.subjectState = subjectState; &#125; &#125; export class Observer &#123; public notify(): void &#123; throw new Error("Abstract Method!"); &#125; &#125; export class ConcreteObserver extends Observer &#123; private name: string; private state: number; private subject: ConcreteSubject; constructor (subject: ConcreteSubject, name: string) &#123; super(); console.log("ConcreteObserver", name, "is created!"); this.subject = subject; this.name = name; &#125; public notify(): void &#123; console.log("ConcreteObserver's notify method"); console.log(this.name, this.state); this.state = this.subject.SubjectState; &#125; get Subject(): ConcreteSubject &#123; return this.subject; &#125; set Subject(subject: ConcreteSubject) &#123; this.subject = subject; &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Behavioral Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式(Proxy)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FProxy%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 代理模式的定义 代理模式(Proxy Pattern) ：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英 文叫做Proxy或Surrogate，它是一种对象结构型模式。 代理模式包含三个角色：Subject: 抽象主题角色Proxy: 代理主题角色RealSubject: 真实主题角色 ES6实现1234567891011121314151617181920212223242526272829303132333435class Subject &#123; constructor() &#123; console.log('Subject Class created'); &#125; request() &#123; console.log('Subject.request invoked'); &#125;&#125;class RealSubject extends Subject &#123; constructor() &#123; super() console.log('RealSubject Class created'); &#125; request() &#123; console.log('RealSubject.request invoked'); &#125;&#125;class Proxy extends Subject &#123; constructor() &#123; super() console.log('Proxy Class created'); &#125; request() &#123; this.realSubject = new RealSubject(); this.realSubject.request(); &#125;&#125;var proxy = new Proxy()proxy.request() Typescript实现12345678910111213141516171819202122232425262728293031323334namespace ProxyPattern &#123; export interface Subject &#123; doAction(): void; &#125; export class Proxy implements Subject &#123; private realSubject: RealSubject; private s: string; constructor(s: string) &#123; this.s = s; &#125; public doAction(): void &#123; console.log("`doAction` of Proxy(", this.s, ")"); if (this.realSubject === null || this.realSubject === undefined) &#123; console.log("creating a new RealSubject."); this.realSubject = new RealSubject(this.s); &#125; this.realSubject.doAction(); &#125; &#125; export class RealSubject implements Subject &#123; private s: string; constructor(s: string) &#123; this.s = s; &#125; public doAction(): void &#123; console.log("`doAction` of RealSubject", this.s, "is being called!"); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Structural Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式(Singleton)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FSingleton%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 单例模式的定义 某个类只能有一个实例； 它必须自行创建这个实例； 它必须自行向整个系统提供这个实例。 单例模式的实现过程中，需要注意如下三点： 单例类的构造函数为私有； 提供一个自身的静态私有成员变量； 提供一个公有的静态工厂方法。 ES6实现1234567891011121314class Singleton &#123; constructor(data) &#123; if (Singleton.prototype.Instance === undefined) &#123; this.data = data; Singleton.prototype.Instance = this; &#125; return Singleton.prototype.Instance; &#125;&#125;let ob1 = new Singleton.getInstance();let ob2 = new Singleton("two");console.log(ob1 === ob2); Typescript实现12345678910111213141516class Singleton &#123; private static instance: Singleton; constructor() &#123;&#125; static get Instance() &#123; if (this.instance === null || this.instance === undefined) &#123; this.instance = new Singleton(); &#125; return this.instance; &#125;&#125;let ob1 = new Singleton("one");let ob2 = new Singleton("two");console.log(ob1 === ob2); 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Creational Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单工厂模式(Factory)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FSimpleFactory%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 简单工厂模式的定义 简单工厂模式：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。 简单工厂模式包含三个角色： Factory-工厂角色负责实现创建所有实例的内部逻辑； Product-抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口； ConcreteProduct-具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。 ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243class Product &#123; constructor() &#123; console.log('Product Class created'); &#125;&#125;class ConcreteProduct extends Product &#123; constructor() &#123; super(); console.log('ConcreteProduct Class created'); &#125;&#125;class Creator &#123; constructor() &#123; console.log('Creator Class created'); &#125; factoryMethod() &#123; console.log('Creator.factoryMethod created'); &#125; anOperation() &#123; console.log('Creator.anOperation created'); this.product = this.factoryMethod(); console.log(this.product instanceof ConcreteProduct); &#125;&#125;class ConcreteCreator extends Creator &#123; constructor() &#123; super(); console.log('ConcreteCreator Class created'); &#125; factoryMethod() &#123; return new ConcreteProduct(); &#125;&#125;var factory = new ConcreteCreator();factory.anOperation(); Typescript实现123456789101112131415161718192021222324252627interface AbstractProduct &#123; method(param?: any) : void;&#125;class ConcreteProductA implements AbstractProduct &#123; method = (param?: any) =&gt; &#123; return "Method of ConcreteProductA"; &#125;&#125;class ConcreteProductB implements AbstractProduct &#123; method = (param?: any) =&gt; &#123; return "Method of ConcreteProductB"; &#125;&#125;class ProductFactory &#123; public static createProduct(type: string) : AbstractProduct &#123; if (type === "A") &#123; return new ConcreteProductA(); &#125; else if (type === "B") &#123; return new ConcreteProductB(); &#125; return null; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Creational Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态模式(State)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FState%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 状态模式的定义 状态模式允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。 其别名为状态对象，状态模式是一种对象行为型模式。 状态模式包含二个角色： Context-环境类又称为上下文类，它是拥有状态的对象，在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象，可以定义初始状态； State-抽象状态类用于定义一个接口以封装与环境类的一个特定状态相关的行为； ConcreteState-具体状态类是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。 ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Context &#123; constructor(state) &#123; console.log("Context Class created"); switch (state) &#123; case "A": this.state = new ConcreteStateA() break case "B": this.state = new ConcreteStateB() break default: this.state = new ConcreteStateA() &#125; &#125; request() &#123; console.log('Context.request invoked'); this.state.handle(this); &#125;&#125;class State &#123; constructor() &#123; console.log("State Class created"); &#125; handle() &#123; console.log('State.handle invoked'); &#125;&#125;class ConcreteStateA extends State &#123; constructor() &#123; super(); console.log("ConcreteStateA Class created"); &#125; handle(context) &#123; console.log('ConcreteStateA.handle invoked'); &#125;&#125;class ConcreteStateB extends State &#123; constructor() &#123; super(); console.log("ConcreteStateB Class created"); &#125; handle(context) &#123; console.log('ConcreteStateB.handle invoked'); &#125;&#125;let context = new Context("A")context.request() Typescript实现12345678910111213141516171819202122232425262728293031323334353637383940namespace StatePattern &#123; export interface State &#123; handle(context: Context): void; &#125; export class ConcreteStateA implements State &#123; public handle(context: Context): void &#123; console.log("`handle` method of ConcreteStateA is being called!"); context.State = new ConcreteStateB(); &#125; &#125; export class ConcreteStateB implements State &#123; public handle(context: Context): void &#123; console.log("`handle` method of ConcreteStateB is being called!"); context.State = new ConcreteStateA(); &#125; &#125; export class Context &#123; private state: State; constructor(state: State) &#123; this.state = state; &#125; get State(): State &#123; return this.state; &#125; set State(state: State) &#123; this.state = state; &#125; public request(): void &#123; console.log("request is being called!"); this.state.handle(this); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Behavioral Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>状态模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[访问者模式(Visitor)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FVisitor%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 访问者模式的定义 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 ES6实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798class Visitor &#123; constructor() &#123; console.log('Visitor Class created!'); &#125; visitConcreteElementA(ConcreteElementA) &#123; console.log('Visitor.visitConcreteElementA invoked'); &#125; visitConcreteElementB(ConcreteElementB) &#123; console.log('Visitor.visitConcreteElementB invoked'); &#125;&#125;class ConcreteVisitor1 extends Visitor &#123; constructor() &#123; super(); console.log('ConcreteVisitor1 Class created!'); &#125; visitConcreteElementA(ConcreteElementA) &#123; console.log('ConcreteVisitor1.visitConcreteElementA invoked'); &#125; visitConcreteElementB(ConcreteElementB) &#123; console.log('ConcreteVisitor1.visitConcreteElementB invoked'); &#125;&#125;class ConcreteVisitor2 extends Visitor &#123; constructor() &#123; super(); console.log('ConcreteVisitor2 Class created!'); &#125; visitConcreteElementA(ConcreteElementA) &#123; console.log('ConcreteVisitor2.visitConcreteElementA invoked'); &#125; visitConcreteElementB(ConcreteElementB) &#123; console.log('ConcreteVisitor2.visitConcreteElementB invoked'); &#125;&#125;class ObjectStructure &#123; constructor() &#123; console.log('ObjectStructure Class created!'); &#125;&#125;class Element &#123; constructor() &#123; console.log('Element Class created!'); &#125; Accept(visitor) &#123; console.log('Element.visitConcreteElementB invoked'); &#125;&#125;class ConcreteElementA extends Element &#123; constructor() &#123; super(); console.log('ConcreteElementA Class created!'); &#125; accept(visitor) &#123; console.log('ConcreteElementA.accept invoked'); visitor.visitConcreteElementA(this); &#125; operationA() &#123; console.log('ConcreteElementA.operationA invoked'); &#125;&#125;class ConcreteElementB extends Element &#123; constructor() &#123; super(); console.log('ConcreteElementB Class created!'); &#125; accept(visitor) &#123; console.log('ConcreteElementB.accept invoked'); visitor.visitConcreteElementB(this); &#125; operationB() &#123; console.log('ConcreteElementB.operationB invoked'); &#125;&#125;let visitor1 = new ConcreteVisitor1();let visitor2 = new ConcreteVisitor2();let elementA = new ConcreteElementA();let elementB = new ConcreteElementB();elementA.accept(visitor1);elementB.accept(visitor2); Typescript实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768namespace VisitorPattern &#123; export interface Visitor &#123; visitConcreteElement1(concreteElement1: ConcreteElement1): void; visitConcreteElement2(concreteElement2: ConcreteElement2): void; &#125; export class ConcreteVisitor1 implements Visitor &#123; public visitConcreteElement1(concreteElement1: ConcreteElement1): void &#123; console.log("`visitConcreteElement1` of ConcreteVisitor1 is being called!"); &#125; public visitConcreteElement2(concreteElement2: ConcreteElement2): void &#123; console.log("`visitConcreteElement2` of ConcreteVisitor1 is being called!"); &#125; &#125; export class ConcreteVisitor2 implements Visitor &#123; public visitConcreteElement1(concreteElement1: ConcreteElement1): void &#123; console.log("`visitConcreteElement1` of ConcreteVisitor2 is being called!"); &#125; public visitConcreteElement2(concreteElement2: ConcreteElement2): void &#123; console.log("`visitConcreteElement2` of ConcreteVisitor2 is being called!"); &#125; &#125; export interface Element &#123; operate(visitor: Visitor): void; &#125; export class ConcreteElement1 implements Element &#123; public operate(visitor: Visitor): void &#123; console.log("`operate` of ConcreteElement1 is being called!"); visitor.visitConcreteElement1(this); &#125; &#125; export class ConcreteElement2 implements Element &#123; public operate(visitor: Visitor): void &#123; console.log("`operate` of ConcreteElement2 is being called!"); visitor.visitConcreteElement2(this); &#125; &#125; export class Objs &#123; private elements: Element[] = []; public attach(e: Element): void &#123; this.elements.push(e); &#125; public detach(e: Element): void &#123; var index = this.elements.indexOf(e); this.elements.splice(index, 1); &#125; public operate(visitor: Visitor): void &#123; var i = 0, max = this.elements.length; for(; i &lt; max; i += 1) &#123; this.elements[i].operate(visitor); &#125; &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Behavioral Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>访问者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板方法模式(TemplateMethod)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FTemplateMethod%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 模板方法模式的定义 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 ES6实现12345678910111213141516171819202122232425262728293031323334353637class AbstractClass &#123; constructor() &#123; console.log('AbstractClass Class created!'); &#125; templateMethod() &#123; console.log('AbstractClass.templateMethod invoked'); this.primitiveOperation1(); this.primitiveOperation2(); &#125; primitiveOperation1() &#123; console.log('AbstractClass.primitiveOperation1 invoked'); &#125; primitiveOperation2() &#123; console.log('AbstractClass.primitiveOperation2 invoked'); &#125;&#125;class ConcreteClass extends AbstractClass &#123; constructor() &#123; super(); console.log('ConcreteClass Class created!'); &#125; primitiveOperation1() &#123; console.log('ConcreteClass.primitiveOperation1 invoked'); &#125; primitiveOperation2() &#123; console.log('ConcreteClass.primitiveOperation2 invoked'); &#125;&#125;let obj = new ConcreteClass();obj.templateMethod(); Typescript实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950namespace TemplateMethodPattern &#123; export class AbstractClass &#123; public method1(): void &#123; throw new Error("Abstract Method"); &#125; public method2(): void &#123; throw new Error("Abstract Method"); &#125; public method3(): void &#123; throw new Error("Abstract Method"); &#125; public templateMethod(): void &#123; console.log("templateMethod is being called"); this.method1(); this.method2(); this.method3(); &#125; &#125; export class ConcreteClass1 extends AbstractClass &#123; public method1(): void &#123; console.log("method1 of ConcreteClass1"); &#125; public method2(): void &#123; console.log("method2 of ConcreteClass1"); &#125; public method3(): void &#123; console.log("method3 of ConcreteClass1"); &#125; &#125; export class ConcreteClass2 extends AbstractClass &#123; public method1(): void &#123; console.log("method1 of ConcreteClass2"); &#125; public method2(): void &#123; console.log("method2 of ConcreteClass2"); &#125; public method3(): void &#123; console.log("method3 of ConcreteClass2"); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Behavioral Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>模板方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[责任链模式(Chain of Responsibility)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FchainOfResponsibility%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849'use strict';class Handler &#123; constructor() &#123; console.log('Handler Class created'); &#125; handleRequest() &#123; console.log('Handler.handleRequest invoked'); &#125;&#125;class ConcreteHandler1 extends Handler &#123; constructor() &#123; super(); console.log('ConcreteHandler1 Class created'); &#125; setSuccessor(successor) &#123; this.successor = successor; console.log('ConcreteHandler1.setSuccessor invoked'); &#125; handleRequest(request) &#123; console.log('ConcreteHandler1.handleRequest invoked'); if (request === 'run') console.log('ConcreteHandler1 has handled the request'); else &#123; console.log('ConcreteHandler1 calls his successor'); this.successor.handleRequest(request); &#125; &#125;&#125;class ConcreteHandler2 extends Handler &#123; constructor() &#123; super(); console.log('ConcreteHandler2 Class created'); &#125; handleRequest(request) &#123; console.log('ConcreteHandler2.handleRequest invoked'); &#125;&#125;let handle1 = new ConcreteHandler1();let handle2 = new ConcreteHandler2();handle1.setSuccessor(handle2);handle1.handleRequest('run');handle1.handleRequest('stay'); Typescript实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455namespace ChainOfResponsibilityPattern &#123; export class Handler &#123; private handler: Handler; private req: number; constructor(req: number) &#123; this.req = req; &#125; public setHandler(handler: Handler): void &#123; this.handler = handler; &#125; public operation(msg: string, req: number): void &#123; if (req &lt;= this.req) &#123; this.handlerRequest(msg) &#125; else if (this.handler !== null &amp;&amp; this.handler !== undefined) &#123; this.handler.operation(msg, req); &#125; &#125; public handlerRequest(msg: string): void &#123; throw new Error("Abstract method!"); &#125; &#125; export class ConcreteHandler1 extends Handler &#123; constructor(req: number) &#123; super(req); &#125; public handlerRequest(msg: string) &#123; console.log("Message (ConcreteHandler1) :: ", msg); &#125; &#125; export class ConcreteHandler2 extends Handler &#123; constructor(req: number) &#123; super(req); &#125; public handlerRequest(msg: string) &#123; console.log("Message :: (ConcreteHandler2) ", msg); &#125; &#125; export class ConcreteHandler3 extends Handler &#123; constructor(req: number) &#123; super(req); &#125; public handlerRequest(msg: string) &#123; console.log("Message :: (ConcreteHandler3) ", msg); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Behavioral Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>责任链模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式(Strategy)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FStrategy%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 策略模式的定义 策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。 策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。。 策略模式包含三个角色： Context-环境类在解决某个问题时可以采用多种策略，在环境类中维护一个对抽象策略类的引用实例; Strategy-抽象策略类为所支持的算法声明了抽象方法，是所有策略类的父类; ConcreteStrategy-具体策略类实现了在抽象策略类中定义的算法。 ES6实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Context &#123; constructor(type) &#123; console.log('Context Class created!'); switch (type) &#123; case "A": this.strategy = new ConcreteStrategyA() break case "B": this.strategy = new ConcreteStrategyB() break default: this.strategy = new ConcreteStrategyA() &#125; &#125; contextInterface() &#123; console.log('Context.contextInterface invoked'); this.strategy.algorithmInterface() &#125;&#125;class Strategy &#123; constructor() &#123; console.log('Strategy Class created!'); &#125; algorithmInterface() &#123; console.log('Strategy.algorithmInterface invoked'); &#125;&#125;class ConcreteStrategyA extends Strategy &#123; constructor() &#123; super(); console.log('ConcreteStrategyA Class created!'); &#125; algorithmInterface() &#123; console.log('ConcreteStrategyA.algorithmInterface invoked'); &#125;&#125;class ConcreteStrategyB extends Strategy &#123; constructor() &#123; super(); console.log('ConcreteStrategyB Class created!'); &#125; algorithmInterface() &#123; console.log('ConcreteStrategyB.algorithmInterface invoked'); &#125;&#125;let contextA = new Context("A");contextA.contextInterface();let contextB = new Context("B");contextB.contextInterface(); Typescript实现1234567891011121314151617181920212223242526272829303132333435namespace StrategyPattern &#123; export interface Strategy &#123; execute(): void; &#125; export class ConcreteStrategy1 implements Strategy &#123; public execute(): void &#123; console.log("`execute` method of ConcreteStrategy1 is being called"); &#125; &#125; export class ConcreteStrategy2 implements Strategy &#123; public execute(): void &#123; console.log("`execute` method of ConcreteStrategy2 is being called"); &#125; &#125; export class ConcreteStrategy3 implements Strategy &#123; public execute(): void &#123; console.log("`execute` method of ConcreteStrategy3 is being called"); &#125; &#125; export class Context &#123; private strategy: Strategy; constructor(strategy: Strategy) &#123; this.strategy = strategy; &#125; public executeStrategy(): void &#123; this.strategy.execute(); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Behavioral Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
</search>