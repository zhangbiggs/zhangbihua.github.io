<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[prototype和__proto__(个人理解)]]></title>
    <url>%2F2017%2F07%2F13%2FprototypeAndProto%2F</url>
    <content type="text"><![CDATA[放关系图 Object构造函数，创建一个对象包装器。Function构造函数， 创建一个新的Function对象。 在 JavaScript 中, 每个函数实际上都是一个Function对象。引用ECMAScript的解释 Each constructor is a function that has a property named “prototype” that is used to implement prototype-based inheritance and shared properties 翻译： 每个构造器都是有着“prototype”属性的函数，用于实现基于原型的继承和共享属性 在javascript中， 有且只有Function构造器的prototype === __proto__ 1Function.ptototype === Function.__proto__ // === true 为什么Function构造器会有这样的设计，原因是因为js没有类的机制，是通过对象的__proto__属性指向父类的prototype属性实现 引用ECMAScript的解释 CF is a constructor (and also an object). Five objects have been created by using new expressions: cf1, cf2, cf3, cf4, and cf5. Each of these objects contains properties named q1 and q2. The dashed lines represent the implicit prototype relationship; so, for example, cf3’s prototype is CFp. The constructor, CF, has two properties itself, named P1 and P2, which are not visible to CFp, cf1, cf2, cf3, cf4, or cf5. The property named CFP1 in CFp is shared by cf1, cf2, cf3, cf4, and cf5 (but not by CF), as are any properties found in CFp’s implicit prototype chain that are not named q1, q2, or CFP1. Notice that there is no implicit prototype link between CF and CFp.Unlike class-based object languages, properties can be added to objects dynamically by assigning values to them. That is, constructors are not required to name or assign values to all or any of the constructed object’s properties. In the above diagram, one could add a new shared property for cf1, cf2, cf3, cf4, and cf5 by assigning a new value to the property in CFp. 翻译： CF是一个构造（以及一个对象）。五个对象已经通过使用创建的new：表达式 CF 1，CF 2，CF 3，CF 4，和CF 5。每个对象包含一个名为性质Q1和Q2。虚线表示隐式原型关系; 因此，例如， CF 3的原型是CF p。的构造，CF，有两个属性本身，命名为P1和P2，这是不可见CF p，CF 1，CF 2，CF 3， CF 4，或CF 5。命名属性CFP1在 CF p是由共享CF 1，CF 2，CF 3， CF 4，和CF 5（而不是由CF），因为是在发现的任何属性 CF p未命名的隐式原型链Q1， Q2，或CFP1。请注意，之间不存在隐式原型链接CF和CF p。 不像基于类的对象的语言，属性可以动态地将它们赋值被添加到对象。也就是说，构造函数不需要命名或赋值构造的对象的属性的全部或任何。另外，在上述图中，人们可以添加对新的共享属性CF 1，CF 2，CF 3， CF 4，和CF 5 通过在属性分配一个新的值CF p。 实现一个函数的声明以及在这个函数的prototype属性加一个属性1234567function Animate (name) &#123; this.name = name &#125;Animate.prototype.sayName = function () &#123; console.log(this.name)&#125;var myAnimate = new Animate('nini') 因为我们在声明Animate函数时，broswer runtime 载入Function构造器，Animate.prototype有两个属性{constructor: XX，__proto__:xxx},1234Animate.prototype.__proto__ === Function.prototype.__proto__ &amp;&amp; Animate.prototype.__proto__ === Object.prototype Animate.__proto__ === Function.__proto__animate.__proto__ !== Animate.prototype &amp;&amp; Animate.__proto__.__proto__ === Animate.prototype.__proto__, Animate.__proto__.__proto__ === Animate.prototype.__proto__ animate.__proto__ 和 animate.prototype 的原型链(__proto__)都指向Object.prototype NOTE: 前面我们说过了Function构造器是js中唯一一个prototype属性 等于 原型链（__proto__)属性的对象( Function.prototype === Function.__proto__) 为构造函数设置一个prototype属性。这个属性包含一个对象（以下简称”prototype对象”），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。实例对象一旦创建，将自动引用prototype对象的属性和方法(Function.prototype === Function.__proto__ 的设计就是为了实现这个功能)也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。 在例子new Animate(‘nini’)时，一个新对象被创建。它继承自Animate.prototype 实现一个简单的继承类12345678910111213141516171819202122232425262728293031function Animate (name) &#123; this.name = name &#125;Animate.prototype.sayName = function () &#123; console.log(this.name)&#125;function Dog (name, color) &#123; Animate.call(this, name) this.color = color&#125;Dog.prototype = Object.create(Animate.prototype,&#123; // 设置Dog.prototype的\_\_proto\_\_为animate.prototype sayColor: &#123; value: function () &#123; console.log(this.color) &#125;, enumerable: true, configurable: true, writable: true &#125;&#125;)var myAnimate = new Animate('nini')var myDog = new Dog('jiji', 'red');myAnimate.sayName() // ===&gt; 'nini'myDog.sayName() // ===&gt; 'jiji'myDog.sayColor() // ===&gt; 'red'Dog.say() // Uncaught TypeError: Dog.say is not a functionAnimate.say() // Uncaught TypeError: Animate.say is not a function 参考： mdn]]></content>
      <categories>
        <category>javascript</category>
        <category>MDN</category>
      </categories>
      <tags>
        <tag>prototype和__proto__</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise]]></title>
    <url>%2F2017%2F07%2F13%2FPromise%2F</url>
    <content type="text"><![CDATA[Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。(简单点说就是处理异步请求。。我们经常会做些承诺，如果我赢了你就嫁给我，如果输了我就嫁给你之类的诺言。这就是promise的中文含义。一个诺言，一个成功，一个失败。) new Promise( / executor / function(resolve, reject) {…}); 参数executor(resolve, reject)该函数会马上被调用，它带有两个参数的函数对象： executor是一个带有resolve和reject两个参数的函数 。executor 函数在Promise构造函数执行时同步执行，被传递resolve和reject函数（executor 函数在Promise构造函数返回新建对象前被调用）。resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled(完成)或rejected（失败）。executor 内部通常会执行一些异步操作，一旦完成，可以调用resolve函数来将promise状态改成fulfilled，或者在发生错误时将它的状态改为rejected 解决函数resolve()用特定值满足绑定的promise，或者把状态传递到一个已存在的promise。如果绑定的promise已经被解决（可能是一个值，也可能是一个rejection，或者是另一个promise），该方法不会做任何事。 note: 用特定值满足绑定的promise，或者把状态传递到一个已存在的promise。如果绑定的promise已经被解决（可能是一个值，也可能是一个rejection，或者是另一个promise），该方法不会做任何事。 拒绝函数reject()用特定原因拒绝绑定的promise。如果promise已经被解决了，不管是值，拒绝，还是另一个promise，这个方法都不会做任何事。 描述Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers ）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象 一个 Promise有以下几种状态: 未完成状态(pending), 此时完成值还不可用，他是唯一一个能够转换为其他状态的状态。 已完成状态(fulfilled), 此时完成值可用，完成值与promise永久绑定，可为任意值，包括undefined 拒绝状态(rejected), 出现错误时，拒绝理由与promise永久绑定，可为任意值，包括undefined，一般情况下为Error对象 pending 状态的 Promise 对象可能触发fulfilled 状态并传递一个值给相应的状态处理方法，也可能触发失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当Promise状态为fulfilled时，调用 then 的 onfulfilled 方法，当Promise状态为rejected时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。 因为 Promise.prototype.then 和 Promise.prototype.catch 方法返回promise 对象， 所以它们可以被链式调用。 ##构造函数创建一个新的promise，初始化为等待状态，并提供解决函数的引用，用于改变其状态。new Promise(executor); 方法Promise.all(iterable) 这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个promise对象的状态集合。（可以参考jQuery.when方法—译者注） 123456789var p1 = Promise.resolve(3);var p2 = 1337;var p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 100, "foo");&#125;); Promise.all([p1, p2, p3]).then(values =&gt; &#123; console.log(values); // [3, 1337, "foo"] &#125;); Promise.race(iterable) 当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。 12345678910111213141516171819202122232425ar p1 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 500, "one"); &#125;);var p2 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 100, "two"); &#125;);Promise.race([p1, p2]).then(function(value) &#123; console.log(value); // "two" // 两个都完成，但 p2 更快&#125;);var p3 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 100, "three");&#125;);var p4 = new Promise(function(resolve, reject) &#123; setTimeout(reject, 500, "four"); &#125;);Promise.race([p3, p4]).then(function(value) &#123; console.log(value); // "three" // p3 更快，所以它完成了 &#125;, function(reason) &#123; // 未被调用&#125;); Promise.reject(reason) 返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法 1234567891011Promise.reject("Testing static reject").then(function(reason) &#123; // 未被调用&#125;, function(reason) &#123; console.log(reason); // "测试静态拒绝"&#125;);Promise.reject(new Error("fail")).then(function(error) &#123; // 未被调用&#125;, function(error) &#123; console.log(error); // 堆栈跟踪&#125;); Promise.resolve(value) 返回一个状态由给定value决定的Promise对象。如果该值是一个Promise对象，则直接返回该对象；如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Resolve另一个promise对象var original = Promise.resolve(true);var cast = Promise.resolve(original);cast.then(function(v) &#123; console.log(v); // true&#125;);// resolve thenable的对象们并抛出错误// Resolve一个thenable对象var p1 = Promise.resolve(&#123; then: function(resolve, onReject) &#123; resolve("resolve!"); &#125;&#125;);console.log(p1 instanceof Promise) // true, 这是一个Promise对象p1.then(function(v) &#123; console.log(v); // 输出"resolve!" &#125;, function(e) &#123; // 不会被调用&#125;);// Thenable在callback之前抛出异常// Promise rejectsvar thenable = &#123; then: function(resolve) &#123; throw new TypeError("Throwing"); resolve("Resolving");&#125;&#125;;var p2 = Promise.resolve(thenable);p2.then(function(v) &#123; // 不会被调用&#125;, function(e) &#123; console.log(e); // TypeError: Throwing&#125;);// Thenable在callback之后抛出异常// Promise resolvesvar thenable = &#123; then: function(resolve) &#123; resolve("Resolving"); throw new TypeError("Throwing");&#125;&#125;;var p3 = Promise.resolve(thenable);p3.then(function(v) &#123; console.log(v); // 输出"Resolving"&#125;, function(e) &#123; // 不会被调用&#125;); Promise 原型属性 Promise.prototype.constructor 返回创建了实例原型的函数. 默认为 Promise 函数. 方法 Promise.prototype.catch(onRejected) 添 p2 = Promise.resolve(thenable);p2.then(function(v) {// 不会被调用}, function(e) {console.log(e); // TypeError: Throwing}); // Thenable在callback之后抛出异常// Promise resolvesvar thenable = { then: function(resolve) { resolve(“Resolving”); throw new TypeError(“Throwing”);}}; var p3 = Promise.resolve(thenable);p3.then(function(v) { console.log(v); // 输出”Resolving”}, function(e) { // 不会被调用});回调到当前 promise, 返回一个新的promise。如果这个回调被调用，新 promise 将以它的返回值来resolve，否则如果当前promise 进入fulfilled状态，则以当前promise的肯定结果作为新promise的肯定结果.1234567891011121314151617181920- Promise.prototype.then(onFulfilled, onRejected)添加肯定和否定回调到当前 promise, 返回一个新的 promise, 将以回调的返回值 来resolve.## 示例```jsvar myFirstPromise = new Promise(function(resolve, reject)&#123; //当异步代码执行成功时，我们才会调用resolve(...), 当异步代码失败时就会调用reject(...) //在本例中，我们使用setTimeout(...)来模拟异步代码，实际编码时可能是XHR请求或是HTML5的一些API方法. setTimeout(function()&#123; resolve(&quot;成功!&quot;); //代码正常执行！ &#125;, 250);&#125;);myFirstPromise.then(function(successMessage)&#123; //successMessage的值是上面调用resolve(...)方法传入的值. //successMessage参数不一定非要是字符串类型，这里只是举个例子 console.log(&quot;Yay! &quot; + successMessage);&#125;); 参考： mdn JavaScript 标准参考教程 [JavaScript Promise](https://developers.google.com/web/fundamentals/getting-started/primers/promises?hl=zh-cn]]></content>
      <categories>
        <category>javascript</category>
        <category>MDN</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class]]></title>
    <url>%2F2017%2F07%2F13%2FClass%2F</url>
    <content type="text"><![CDATA[ECMAScript 2015 中引入的 JavaScript class 主要是 JavaScript 现有的基于原型的继承的语法糖。 类语法不是向JavaScript引入一个新的面向对象的继承模型。JavaScript类提供了一个更简单和更清晰的语法来创建对象并处理继承。 定义类实际上是个“特殊的函数”，就像你能够定义的函数表达式和函数声明一样，类语法有两个组成部分：类表达式和类声明。 类声明定义一个类的一种方法是使用一个类声明。要声明一个类，你可以使用带有class关键字的类名（这里是“Rectangle”）。123456class Rectangle &#123; constructor(height, width) &#123; this.height = height; this.width = width; &#125;&#125; 提升函数声明和类声明之间的一个重要区别是函数声明会声明提升，类声明不会。你首先需要声明你的类，然后访问它，12345let p = new Rectangle(); // ReferenceErrorclass Rectangle &#123;&#125; 类表达式一个类表达式是定义一个类的另一种方式。类表达式可以是被命名的或匿名的。赋予一个命名类表达式的名称是类的主体的本地名称。123456789101112131415/* 匿名类 */ let Rectangle = class &#123; constructor(height, width) &#123; this.height = height; this.width = width; &#125;&#125;;/* 命名的类 */ let Rectangle = class Rectangle &#123; constructor(height, width) &#123; this.height = height; this.width = width; &#125;&#125;; 类体和方法定义一个类的类体是一对花括号/大括号 {} 中的部分。这是你定义类成员的位置，如方法或构造函数。 严格模式类声明和类表达式的主体都执行在严格模式下。 构造函数构造函数方法是一个特殊的方法，其用于创建和初始化使用一个类创建的一个对象。一个类只能拥有一个名为 “constructor”的特殊方法。如果类包含多个构造函数的方法，则将抛出 一个SyntaxError 。 一个构造函数可以使用 super 关键字来调用一个父类的构造函数。 原型方法静态方法static 关键字用来定义一个类的一个静态方法。调用静态方法而不实例化其类，不能通过一个类实例调用静态方法。静态方法通常用于为一个应用程序创建工具函数。 使用 extends 创建子类extends 关键字在类声明或类表达式中用于创建一个类作为另一个类的一个子类。12345678910111213141516171819class Animal &#123; constructor(name) &#123; this.name = name; &#125; speak() &#123; console.log(this.name + ' makes a noise.'); &#125;&#125;class Dog extends Animal &#123; speak() &#123; console.log(this.name + ' barks.'); &#125;&#125;var d = new Dog('Mitzie');// 'Mitzie barks.'d.speak(); 如果子类中存在构造函数，则需要在使用“this”之前首先调用super（）。也可以扩展传统的基于函数的“类”： 12345678910111213141516function Animal (name) &#123; this.name = name; &#125;Animal.prototype.speak = function () &#123; console.log(this.name + ' makes a noise.');&#125;class Dog extends Animal &#123; speak() &#123; super.speak(); console.log(this.name + ' barks.'); &#125;&#125;var d = new Dog('Mitzie');d.speak(); 请注意，类不能扩展常规（不可构造/非构造的）对象。如果要继承常规对象，可以改用Object.setPrototypeOf()1234567891011121314151617181920var Animal = &#123; speak() &#123; console.log(this.name + ' makes a noise.'); &#125;&#125;;class Dog &#123; constructor(name) &#123; this.name = name; &#125; speak() &#123; super.speak(); console.log(this.name + ' barks.'); &#125;&#125;Object.setPrototypeOf(Dog.prototype, Animal);var d = new Dog('Mitzie');d.speak(); Species你可能希望在派生数组类 MyArray 中返回 Array对象。这种类/种类模式允许你覆盖默认的构造函数。 例如，当使用像map()返回默认构造函数的方法时，您希望这些方法返回一个父Array对象，而不是MyArray对象。Symbol.species 符号可以让你这样做：1234567891011class MyArray extends Array &#123; // Overwrite species to the parent Array constructor static get [Symbol.species]() &#123; return Array; &#125;&#125;var a = new MyArray(1,2,3);var mapped = a.map(x =&gt; x * x);console.log(mapped instanceof MyArray); // falseconsole.log(mapped instanceof Array); // true 使用 super 调用超类super 关键字用于调用对象的父对象上的函数。12345678910111213141516class Cat &#123; constructor(name) &#123; this.name = name; &#125; speak() &#123; console.log(this.name + ' makes a noise.'); &#125;&#125;class Lion extends Cat &#123; speak() &#123; super.speak(); console.log(this.name + ' roars.'); &#125;&#125; Mix-ins 混合抽象子类或者 mix-ins 是类的模板。 一个 ECMAScript 类只能有一个单超类，所以想要从工具类来多重继承的行为是不可能的。子类继承的只能是父类提供的功能性。因此，例如，从工具类的多重继承是不可能的。该功能必须由超类提供。 一个以超类作为输入的函数和一个继承该超类的子类作为输出可以用于在ECMAScript中实现混合1234567var calculatorMixin = Base =&gt; class extends Base &#123; calc() &#123; &#125;&#125;;var randomizerMixin = Base =&gt; class extends Base &#123; randomize() &#123; &#125;&#125;; 使用 mix-ins 的类可以像下面这样写：1使用 mix-ins 的类可以像下面这样写： example运用class super, static extend…123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206// Example 1: Creating a new class (declaration-form)// ===============================================================// A base class is defined using the new reserved 'class' keywordclass Polygon &#123; // ..and an (optional) custom class constructor. If one is // not supplied, a default constructor is used instead: // constructor() &#123; &#125; constructor(height, width) &#123; this.name = 'Polygon'; this.height = height; this.width = width; &#125; // Simple class instance methods using short-hand method // declaration sayName() &#123; console.log('Hi, I am a ', this.name + '.'); &#125; sayHistory() &#123; console.log('"Polygon" is derived from the Greek polus (many) ' + 'and gonia (angle).'); &#125; // We will look at static and subclassed methods shortly&#125;// Classes are used just like ES5 constructor functions:let p = new Polygon(300, 400);p.sayName();console.log('The width of this polygon is ' + p.width);// Example 2: Creating a new class (expression-form)// ===============================================================// Our Polygon class above is an example of a Class declaration.// ES6 classes also support Class expressions - just another way// of defining a new class. For example:const MyPoly = class Poly &#123; getPolyName() &#123; console.log('Hi. I was created with a Class expression. My name is ' + Poly.name); &#125;&#125;;let inst = new MyPoly();inst.getPolyName();// Example 3: Extending an existing class// ===============================================================// Classes support extending other classes, but can also extend// other objects. Whatever you extend must be a constructor.//// Let's extend the Polygon class to create a new derived class// called Square.class Square extends Polygon &#123; constructor(length) &#123; // The reserved 'super' keyword is for making super-constructor // calls and allows access to parent methods. // // Here, it will call the parent class' constructor with lengths // provided for the Polygon's width and height super(length, length); // Note: In derived classes, super() must be called before you // can use 'this'. Leaving this out will cause a reference error. this.name = 'Square'; &#125; // Getter/setter methods are supported in classes, // similar to their ES5 equivalents get area() &#123; return this.height * this.width; &#125; set area(value) &#123; this.area = value; &#125;&#125;let s = new Square(5);s.sayName();console.log('The area of this square is ' + s.area);// Example 4: Subclassing methods of a parent class// ===============================================================class Rectangle extends Polygon &#123; constructor(height, width) &#123; super(height, width); this.name = 'Rectangle'; &#125; // Here, sayName() is a subclassed method which // overrides their superclass method of the same name. sayName() &#123; console.log('Sup! My name is ', this.name + '.'); super.sayHistory(); &#125;&#125;let r = new Rectangle(50, 60);r.sayName();// Example 5: Defining static methods// ===============================================================// Classes support static members which can be accessed without an// instance being present.class Triple &#123; // Using the 'static' keyword creates a method which is associated // with a class, but not with an instance of the class. static triple(n) &#123; n = n || 1; return n * 3; &#125;&#125;// super.prop in this example is used for accessing super-properties from// a parent class. This works fine in static methods too:class BiggerTriple extends Triple &#123; static triple(n) &#123; return super.triple(n) * super.triple(n); &#125;&#125;console.log(Triple.triple());console.log(Triple.triple(6));console.log(BiggerTriple.triple(3));// var tp = new Triple();// console.log(tp.triple()); tp.triple is not a function// Example 6: Subclassing built-in classes and DOM// ===============================================================// Extend Date built-inclass MyDate extends Date &#123; constructor() &#123; super(); &#125; getFormattedDate() &#123; var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; return this.getDate() + '-' + months[this.getMonth()] + '-' + this.getFullYear(); &#125;&#125;var aDate = new MyDate();console.log(aDate.getTime());console.log(aDate.getFormattedDate());// Extend Uint8Arrayclass ExtendedUint8Array extends Uint8Array &#123; constructor() &#123; super(10); this[0] = 255; this[1] = 0xFFA; &#125;&#125;var eua = new ExtendedUint8Array();console.log(eua.byteLength);// Extend DOM Audio elementclass MyAudio extends Audio &#123; constructor() &#123; super(); this._lyrics = ''; &#125; get lyrics() &#123; return this._lyrics; &#125; set lyrics(str) &#123; this._lyrics = str; &#125;&#125;var player = new MyAudio();player.controls = true;player.lyrics = 'Never gonna give you up';document.querySelector('body').appendChild(player);console.log(player.lyrics);// Note: The V8 in Chrome 42 supports subclassing built-ins but Arrays.// Subclassing arrays supported in Chrome 43.class Stack extends Array &#123; constructor() &#123; super(); &#125; top() &#123; return this[this.length - 1]; &#125;&#125;var stack = new Stack();stack.push('world');stack.push('hello');console.log(stack.top());console.log(stack.length);]]></content>
      <categories>
        <category>javascript</category>
        <category>MDN</category>
      </categories>
      <tags>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解构赋值]]></title>
    <url>%2F2017%2F07%2F09%2FDestructuringAssignment%2F</url>
    <content type="text"><![CDATA[解构赋值 解构赋值 语法是一个Javascript表达式，这使得可以将值从数组或属性从对象提取到不同的变量中。 作用 交换变量 123456var a = 1;var b = 3;[a, b] = [b, a];console.log(a); // 3console.log(b); // 1 解构数组 12345678910111213141516 let a, b, rest;/* array 解构赋值 */[a, b] = [1, 2];console.log(a); // 1console.log(b); // 2[a, b, ...rest] = [1, 2, 3, 4, 5];console.log(a); // 1console.log(b); // 2console.log(rest); // [3, 4, 5]/* object 解构赋值 */(&#123;a, b&#125; = &#123;a:1, b:2&#125;);console.log(a); // 1console.log(b); // 2 解构对象 1234567891011 var o = &#123;p: 42, q: true&#125;;var &#123;p, q&#125; = o;console.log(p); // 42console.log(q); // true // 用新变量名赋值var &#123;p: foo, q: bar&#125; = o;console.log(foo); // 42console.log(bar); // true 解析一个从函数返回的数组(函数现在可以返回多个值了) 12345678 function f() &#123; return [1, 2];&#125;var a, b; [a, b] = f(); console.log(a); // 1console.log(b); // 2 忽略某些返回值 1234567function f() &#123; return [1, 2, 3];&#125;var [a, , b] = f();console.log(a); // 1console.log(b); // 3 将剩余数组赋值给一个变量 123 var [a, ...b] = [1, 2, 3];console.log(a); // 1console.log(b); // [2, 3] 用正则表达式匹配提取值 12345678var url = "https://developer.mozilla.org/en-US/Web/JavaScript";var parsedURL = /^(\w+)\:\/\/([^\/]+)\/(.*)$/.exec(url);console.log(parsedURL); // ["https://developer.mozilla.org/en-US/Web/JavaScript", "https", "developer.mozilla.org", "en-US/Web/JavaScript"]var [, protocol, fullhost, fullpath] = parsedURL;console.log(protocol); // "https" 函数参数默认值 12345678910function drawES6Chart(&#123;size = 'big', cords = &#123; x: 0, y: 0 &#125;, radius = 25&#125; = &#123;&#125;) &#123; console.log(size, cords, radius); // do some chart drawing&#125;drawES6Chart(&#123; cords: &#123; x: 18, y: 30 &#125;, radius: 30&#125;); 加载模块 1const &#123; Loader, main &#125; = require('toolkit/loader'); 解构嵌套对象和数组 123456789101112131415161718var metadata = &#123; title: "Scratchpad", translations: [ &#123; locale: "de", localization_tags: [ ], last_edit: "2014-04-14T08:43:37", url: "/de/docs/Tools/Scratchpad", title: "JavaScript-Umgebung" &#125; ], url: "/en-US/docs/Tools/Scratchpad"&#125;;var &#123; title: englishTitle, translations: [&#123; title: localeTitle &#125;] &#125; = metadata;console.log(englishTitle); // "Scratchpad"console.log(localeTitle); // "JavaScript-Umgebung" For of 迭代和解构 123456789101112131415161718192021222324252627var people = [ &#123; name: "Mike Smith", family: &#123; mother: "Jane Smith", father: "Harry Smith", sister: "Samantha Smith" &#125;, age: 35 &#125;, &#123; name: "Tom Jones", family: &#123; mother: "Norah Jones", father: "Richard Jones", brother: "Howard Jones" &#125;, age: 25 &#125;];for (var &#123;name: n, family: &#123; father: f &#125; &#125; of people) &#123; console.log("Name: " + n + ", Father: " + f);&#125;// "Name: Mike Smith, Father: Harry Smith"// "Name: Tom Jones, Father: Richard Jones" 从作为函数实参的对象中提取数据、 12345678910111213141516171819function userId(&#123;id&#125;) &#123; return id;&#125;function whois(&#123;displayName: displayName, fullName: &#123;firstName: name&#125;&#125;)&#123; console.log(displayName + " is " + name);&#125;var user = &#123; id: 42, displayName: "jdoe", fullName: &#123; firstName: "John", lastName: "Doe" &#125;&#125;;console.log("userId: " + userId(user)); // "userId: 42"whois(user); // "jdoe is John" 对象属性计算名和解构 1234let key = "z";let &#123; [key]: foo &#125; = &#123; z: "bar" &#125;;console.log(foo); // "bar]]></content>
      <categories>
        <category>javascript</category>
        <category>MDN</category>
      </categories>
      <tags>
        <tag>解构赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成器(Generator)]]></title>
    <url>%2F2017%2F07%2F09%2FgeneratorAndIterator%2F</url>
    <content type="text"><![CDATA[生成器对象生成器对象是由一个 generator function 返回的,并且它符合可迭代协议和迭代器协议。 语法1234567function* gen() &#123; yield 1; yield 2; yield 3;&#125;let g = gen(); 方法 Generator.prototype.next() 返回一个由 yield表达式生成的值。 Generator.prototype.return() 返回给定的值并结束生成器。 Generator.prototype.throw()向生成器抛出一个错误。 function *function* 这种声明方式(function关键字后跟一个星号）会定义一个生成器函数 (generator function)，它返回一个 Generator 对象。 语法function* name([param[, param[, … param]]]) { statements } 描述生成器函数在执行时能中途退出，后面又能重新进入继续执行。而且在函数内定义的变量的状态都会保留，不受中途退出的影响。 调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的迭代器（iterator）对象。当这个迭代器的 next() 方法被首次（后续）调用时，其内的语句会执行到第一个（后续）出现yield表达式的位置为止，该表达式定义了迭代器要返回的值，或者被 yield*委派至另一个生成器函数。next()方法返回一个对象，这个对象包含两个属性：value 和 done，value 属性表示本次 yield 表达式的返回值，done 属性为布尔类型，表示生成器是否已经产出了它最后的值，即生成器函数是否已经返回。 调用 next() 方法时，如果传入了参数，那么这个参数会取代生成器函数中对应执行位置的 yield 表达式（整个表达式被这个值替换） 当在生成器函数中显式 return 时，会导致生成器立即变为完成状态，即调用 next() 方法返回的对象的 done 为 true。如果 return 了一个值，那么这个值会作为下次调用 next() 方法返回的 value 值。 示例简单示例12345678910111213function* idMaker()&#123; var index = 0; while(index&lt;3) yield index++;&#125;var gen = idMaker();console.log(gen.next().value); // 0console.log(gen.next().value); // 1console.log(gen.next().value); // 2console.log(gen.next().value); // undefined// ... yield*的示例12345678910111213141516171819function* anotherGenerator(i) &#123; yield i + 1; yield i + 2; yield i + 3;&#125;function* generator(i)&#123; yield i; yield* anotherGenerator(i); yield i + 10;&#125;var gen = generator(10);console.log(gen.next().value); // 10console.log(gen.next().value); // 11console.log(gen.next().value); // 12console.log(gen.next().value); // 13console.log(gen.next().value); // 20 传递参数12345678910111213function* logGenerator() &#123; console.log(yield);//首次执行的中断处 console.log(yield); console.log(yield);&#125;var gen = logGenerator();// 首次调用 next() 会执行到第一个 yield 语句处gen.next(); gen.next('pretzel'); // pretzelgen.next('california'); // californiagen.next('mayonnaise'); // mayonnaise 显式返回12345678910function* yieldAndReturn() &#123; yield "Y"; return "R";//显式返回处 yield "unreachable";&#125;var gen = yieldAndReturn()console.log(gen.next()); // &#123; value: "Y", done: false &#125;console.log(gen.next()); // &#123; value: "R", done: true &#125;console.log(gen.next()); // &#123; value: undefined, done: true &#125; 生成器函数不能当构造器使用12function* f() &#123;&#125;var obj = new f; // throws "TypeError: f is not a constructor" yield* expression 用于委托给另一个generator 或可迭代对象。语法yield* [[expression]]; 描述yield * 表达式迭代操作数，并yield 它返回的每个值。 yield * 表达式本身的值是当迭代器关闭时返回的值(即，当done时为true)。 示例例子：委托给其他生成器 以下代码中，g1() yield 出去的每个值都会在 g2() 的 next() 方法中返回，就像那些 yield 语句是写在 g2() 里一样。1234567891011121314151617181920function* g1() &#123; yield 2; yield 3; yield 4;&#125;function* g2() &#123; yield 1; yield* g1(); yield 5;&#125;var iterator = g2();console.log(iterator.next()); // &#123; value: 1, done: false &#125;console.log(iterator.next()); // &#123; value: 2, done: false &#125;console.log(iterator.next()); // &#123; value: 3, done: false &#125;console.log(iterator.next()); // &#123; value: 4, done: false &#125;console.log(iterator.next()); // &#123; value: 5, done: false &#125;console.log(iterator.next()); // &#123; value: undefined, done: true &#125; 参考： mdn 迭代器和生成器]]></content>
      <categories>
        <category>javascript</category>
        <category>MDN</category>
      </categories>
      <tags>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js对象属性判断]]></title>
    <url>%2F2017%2F07%2F09%2FinstanceTypeofContructor%2F</url>
    <content type="text"><![CDATA[constructor所有对象都会从它的原型上继承一个 constructor 属性 ,返回一个指向创建了该对象原型的函数引用语法12345678object instanceof constructorfunction Tree(name) &#123; this.name = name;&#125;var myTree = new Tree(&quot;Redwood&quot;);console.log(myTree.constructor ) // ===&gt; function Tree(name) &#123;this.name = name&#125;; isPrototypeOf语法prototypeObj.isPrototypeOf(object) 作用用于测试一个对象是否存在于另一个对象的原型链上。 当需要判断对象的后代是否在特定原型链上，例如，以保证一定的方法或属性将存在该对象上，这时候就需要用到 instanceof。 instanceof语法object instanceof constructor Object.prototype.constructor 特定的函数，用于创建一个对象的原型。 instanof 是用来检测一个对象的原型链是否存在参数Oject的原型链上，js中的继承是基于原型链继承， 类似的 Object.getPrototypeOf(child) === parent.protorype返回true 相对比 Object.getPrototypeOf(child) === grandparent.protorype返回false child instanceof grandparernt返回true 作用instanceof 运算符用来测试 对象(object) 在其原型链(proto) 中是否存在构造函数(constructor) 的 prototype 属性。 __proto__ 是每个 对象 的的属性 prototype 是每个 函数 的属性, Object构造器生成的对象没有prototype属性，Object构造器本身就是一个Function Object.prototype 属性表示 Object 的原型对象。 12345678910111213141516171819202122232425262728293031323334353637383940function A(a)&#123; this.varA = a;&#125;A.prototype = &#123; varA : null, doSomething : function()&#123; // ... &#125;&#125;function B(a, b)&#123; A.call(this, a); this.varB = b;&#125;B.prototype = Object.create(A.prototype, &#123; varB : &#123; value: null, enumerable: true, configurable: true, writable: true &#125;, doSomething : &#123; value: function()&#123; // override A.prototype.doSomething.apply(this, arguments); // call super // ... &#125;, enumerable: true, configurable: true, writable: true &#125;&#125;);var b = new B();b.doSomething()b instanceOf B // ===&gt;trueb instanceOf A // ===&gt;trueObject.getPrototypeOf(b) === B.prototype // ===&gt; trueObject.getPrototypeOf(b) === A.prototype // ===&gt; false 另外对于A B的两个函数对象，B继承A参考： 继承与原型链 12B instanceof A // ===&gt; false 是继承关系不是实例构造Object.getPrototypeOf(B.prototype) === A.prototype // ===&gt; true B函数的prototype的原型是A函数的prototype,以此来实现js的原型继承 Object.prototype.toString.call1234567891011121314151617181920var myObj = &#123;&#125;var myArr = []var myNumber = 1var myStr = 'a'Object.prototype.toString.call(myObj) // ===&gt; '[object Object]' Object.prototype.toString.call(myArr) // ===&gt; '[object Array]' Object.prototype.toString.call(myNumber) // ===&gt; '[object Number]'Object.prototype.toString.call(myStr) // ===&gt; '[object String]'Object.prototype.toString.call(undefined) // ===&gt; '[object undefined]'Object.prototype.toString.call(null) // ===&gt; '[object null]'var a = function () &#123; this.nimei = 'nimie' this.say = function () &#123; console.log('nimei') &#125;&#125;var b ;b. b.say() typeof123456789var myArr = []var myNumber = 1var myStr = 'a'console.log(typeof myObj) // ===&gt; 'object'console.log(typeof myArr) // ===&gt; 'object'console.log(typeof myNumber) // ===&gt; 'number'console.log(typeof myStr) // ===&gt; 'string'console.log(typeof undefined) // ===&gt; 'undefined'console.log(typeof null) // ===&gt; 'object' so, 相对比typeof ,Object.prototype.toString.call 来判断会对象会更加的准确，在使用typeof Array 和 typeof null 结果与 typeof Ojbect 一样是 ‘object’ Array.isArray()用于确定传递的值是否是一个 Array Number.isNan()用于确定传递的值是否是Nan 参考： mdn JavaScript判断对象的类型]]></content>
      <categories>
        <category>javascript</category>
        <category>MDN</category>
      </categories>
      <tags>
        <tag>js对象属性判断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合模式(Composite)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FComposite%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 ES6实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Component &#123; constructor() &#123; console.log('Component Class created'); &#125; operation() &#123; console.log('Component.operation invoked'); &#125; add(Component) &#123; console.log('Component.add invoked'); &#125; remove(Component) &#123; console.log('Component.remove invoked'); &#125; getChild(key) &#123; console.log('Component.getChild invoked'); &#125;&#125;class Leaf extends Component &#123; constructor(name) &#123; super(); this.name = name; console.log('Leaf Class created'); &#125; operation() &#123; console.log('Leaf.operation invoked'); console.log(this.name); &#125;&#125;class Composite extends Component &#123; constructor(name) &#123; super(); this.name = name; this.children = []; console.log('Composite Class created'); &#125; operation() &#123; console.log('Composite operation for: ' + this.name) for (var i in this.children) &#123; this.children[i].operation(); &#125; &#125; add(Component) &#123; console.log('Composite.add invoked'); this.children.push(Component); &#125; remove(Component) &#123; console.log('Composite.remove invoked'); for (var i in this.children) &#123; if (this.children[i] === Component) &#123; this.children.splice(i, 1); &#125; &#125; &#125; getChild(key) &#123; console.log('Composite.getChild invoked'); return this.children[key]; &#125;&#125;var composite1 = new Composite('C1');composite1.add(new Leaf('L1'));composite1.add(new Leaf('L2'));var composite2 = new Composite('C2');composite2.add(composite1);composite1.getChild(1).operation();composite2.operation(); Typescript实现1234567891011121314151617181920212223242526272829303132333435363738394041424344namespace CompositePattern &#123; export interface Component &#123; operation(): void; &#125; export class Composite implements Component &#123; private list: Component[]; private s: String; constructor(s: String) &#123; this.list = []; this.s = s; &#125; public operation(): void &#123; console.log("`operation of `", this.s) for (var i = 0; i &lt; this.list.length; i += 1) &#123; this.list[i].operation(); &#125; &#125; public add(c: Component): void &#123; this.list.push(c); &#125; public remove(i: number): void &#123; if (this.list.length &lt;= i) &#123; throw new Error("index out of bound!"); &#125; this.list.splice(i, 1); &#125; &#125; export class Leaf implements Component &#123; private s: String; constructor(s: String) &#123; this.s = s; &#125; public operation(): void &#123; console.log("`operation` of Leaf", this.s, " is called."); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Structural Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰模式(Decorator)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FDecorator%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 装饰模式的定义 装饰模式：装饰模式用于动态地给一个对象增加一些额外的职责，就增加对象功 能来说，装饰模式比生成子类实现更为灵活。它是一种对象结构型模 式。 装饰模式包含四个角色： Component-抽象构件定义了对象的接口，可以给这些对 象动态增加职责（方法）； ConcreteComponent-具体构件定义了具体的构件对象，实现了 在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）； Decorator-抽象装饰类是抽象构件类的子类，用于给具体构件增加职责，但是具 体职责在其子类中实现； ConcreteDecorator-具体装饰类是抽象装饰类的子类，负责向构 件添加新的职责。 ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Component &#123; constructor() &#123; console.log('Component Class created'); &#125; operation() &#123; console.log('Component.operation invoked'); &#125;&#125;class ConcreteComponent extends Component &#123; constructor() &#123; super(); console.log('ConcreteComponent Class created'); &#125; operation() &#123; console.log('ConcreteComponent.operation invoked'); &#125;&#125;class Decorator extends Component &#123; constructor(component) &#123; super(); this.component = component; console.log('Decorator Class created'); &#125; operation() &#123; console.log('Decorator.operation invoked'); this.component.operation() &#125;&#125;class ConcreteDecoratorA extends Decorator &#123; constructor(component, sign) &#123; super(component); this.addedState = sign; console.log('ConcreteDecoratorA Class created'); &#125; operation() &#123; super.operation(); console.log('ConcreteDecoratorA.operation invoked'); console.log(this.addedState) &#125;&#125;class ConcreteDecoratorB extends Decorator &#123; constructor(component, sign) &#123; super(component); this.addedState = sign; console.log('ConcreteDecoratorB Class created'); &#125; operation() &#123; super.operation(); console.log('ConcreteDecoratorB.operation invoked'); console.log(this.addedState + this.addedState + this.addedState + this.addedState + this.addedState); &#125; addedBehavior() &#123; this.operation(); console.log('ConcreteDecoratorB.operation invoked'); &#125;&#125;var component = new ConcreteComponent();var decoratorA = new ConcreteDecoratorA(component, 'decoratorA');var decoratorB = new ConcreteDecoratorB(component, 'decoratorB');console.log('component: ');component.operation();console.log('decoratorA: ');decoratorA.operation();console.log('decoratorB: ');decoratorB.addedBehavior(); Typescript实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748namespace DecoratorPattern &#123; export interface Component &#123; operation(): void; &#125; export class ConcreteComponent implements Component &#123; private s: String; constructor(s: String) &#123; this.s = s; &#125; public operation(): void &#123; console.log("`operation` of ConcreteComponent", this.s, " is being called!"); &#125; &#125; export class Decorator implements Component &#123; private component: Component; private id: Number; constructor(id: Number, component: Component) &#123; this.id = id; this.component = component; &#125; public get Id(): Number &#123; return this.id; &#125; public operation(): void &#123; console.log("`operation` of Decorator", this.id, " is being called!"); this.component.operation(); &#125; &#125; export class ConcreteDecorator extends Decorator &#123; constructor(id: Number, component: Component) &#123; super(id, component); &#125; public operation(): void &#123; super.operation(); console.log("`operation` of ConcreteDecorator", this.Id, " is being called!"); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Structural Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>装饰模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[外观模式(Facade)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FFacade%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 外观模式的定义 外观模式：在外观模式中，外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面， 外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。 外观模式包含二个角色： Facade-外观角色是在客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理； SubSystem-在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能 ES6实现12345678910111213141516171819202122class Facade &#123; constructor() &#123; console.log("Facade class created"); &#125; gotoPage(dp) &#123; switch (dp) &#123; case "Facade": console.log("This is the Facade"); break; case "AbstractFactory": console.log("This is the AbstractFactory"); break; default: console.log("nothing to be matched"); &#125; &#125;&#125;let facade = new Facade();facade.gotoPage('Facade');facade.gotoPage('AbstractFactory'); Typescript实现12345678910111213141516171819202122232425262728293031323334353637383940namespace FacadePattern &#123; export class Part1 &#123; public method1(): void &#123; console.log("`method1` of Part1"); &#125; &#125; export class Part2 &#123; public method2(): void &#123; console.log("`method2` of Part2"); &#125; &#125; export class Part3 &#123; public method3(): void &#123; console.log("`method3` of Part3"); &#125; &#125; export class Facade &#123; private part1: Part1 = new Part1(); private part2: Part2 = new Part2(); private part3: Part3 = new Part3(); public operation1(): void &#123; console.log("`operation1` is called ==="); this.part1.method1(); this.part2.method2(); console.log("=========================="); &#125; public operation2(): void &#123; console.log("`operation2` is called ==="); this.part1.method1(); this.part3.method3(); console.log("=========================="); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Structural Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>外观模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式(Abstract Factory)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FAbstractFactory%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 抽象工厂模式的定义 抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。 抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构 抽象工厂模式包含四个角色： ConcreteFactory-具体工厂实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中； AbstractProduct-抽象产品为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法； AbstractFactory-抽象工厂用于明生成抽象产品的方法； Product-具体产品定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。 抽象工厂模式适用情况包括： 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节； 系统中有多于一个的产品族，而每次只使用其中某一产品族； 属于同一个产品族的产品将在一起使用； 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。 ES6实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495class AbstractFactory &#123; constructor() &#123; console.log("AbstractFactory class created"); &#125; createProductA(product) &#123; console.log("AbstractFactory.createProductA created"); &#125; createProductB(product) &#123; console.log("AbstractFactory.createProductB created"); &#125;&#125;class ConcreteFactory1 extends AbstractFactory &#123; constructor() &#123; super(); console.log("ConcreteFactory1 class created"); &#125; createProductA(product) &#123; console.log('ConcreteFactory1 createProductA'); return new ProductA1(); &#125; createProductB(product) &#123; console.log('ConcreteFactory1 createProductB'); return new ProductB1(); &#125;&#125;class ConcreteFactory2 extends AbstractFactory &#123; constructor() &#123; super(); console.log("ConcreteFactory2 class created"); &#125; createProductA(product) &#123; console.log('ConcreteFactory2 createProductA'); return new ProductA2(); &#125; createProductB(product) &#123; console.log('ConcreteFactory2 createProductB'); return new ProductB2(); &#125;&#125;class AbstractProductA &#123; constructor() &#123; console.log('AbstractProductA class created'); &#125;&#125;class AbstractProductB &#123; constructor() &#123; console.log('AbstractProductB class created'); &#125;&#125;class ProductA1 extends AbstractProductA &#123; constructor() &#123; super(); console.log('ProductA1 class created'); &#125;&#125;class ProductA2 extends AbstractProductA &#123; constructor() &#123; super(); console.log('ProductA2 class created'); &#125;&#125;class ProductB1 extends AbstractProductB &#123; constructor() &#123; super(); console.log('ProductB1 class created'); &#125;&#125;class ProductB2 extends AbstractProductB &#123; constructor() &#123; super(); console.log('ProductB2 class created'); &#125;&#125;var factory1 = new ConcreteFactory1();var productB1 = factory1.createProductB();var productA1 = factory1.createProductA();var factory2 = new ConcreteFactory2();var productA2 = factory2.createProductA();var productB2 = factory2.createProductB(); Typescript实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273namespace AbstractFactoryPattern &#123; export interface AbstractProductA &#123; methodA(): string; &#125; export interface AbstractProductB &#123; methodB(): number; &#125; export interface AbstractFactory &#123; createProductA(param?: any) : AbstractProductA; createProductB() : AbstractProductB; &#125; export class ProductA1 implements AbstractProductA &#123; methodA = () =&gt; &#123; return "This is methodA of ProductA1"; &#125; &#125; export class ProductB1 implements AbstractProductB &#123; methodB = () =&gt; &#123; return 1; &#125; &#125; export class ProductA2 implements AbstractProductA &#123; methodA = () =&gt; &#123; return "This is methodA of ProductA2"; &#125; &#125; export class ProductB2 implements AbstractProductB &#123; methodB = () =&gt; &#123; return 2; &#125; &#125; export class ConcreteFactory1 implements AbstractFactory &#123; createProductA(param?: any) : AbstractProductA &#123; return new ProductA1(); &#125; createProductB(param?: any) : AbstractProductB &#123; return new ProductB1(); &#125; &#125; export class ConcreteFactory2 implements AbstractFactory &#123; createProductA(param?: any) : AbstractProductA &#123; return new ProductA2(); &#125; createProductB(param?: any) : AbstractProductB &#123; return new ProductB2(); &#125; &#125; export class Tester &#123; private abstractProductA: AbstractProductA; private abstractProductB: AbstractProductB; constructor(factory: AbstractFactory) &#123; this.abstractProductA = factory.createProductA(); this.abstractProductB = factory.createProductB(); &#125; public test(): void &#123; console.log(this.abstractProductA.methodA()); console.log(this.abstractProductB.methodB()); &#125; &#125; &#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Creational Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[享元模式(Flyweight)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FFlyweight%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 享元模式的定义 享元模式：享元模式运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用，它是一种对象结构型模式。 享元模式包含四个角色： Flyweight-抽象享元类声明一个接口，通过它可以接受并作用于外部状态； ConcreteFlyweight-具体享元类实现了抽象享元接口，其实例称为享元对象； UnsharedConcreteFlyweight-非共享具体享元是不能被共享的抽象享元类的子类； FlyweightFactory-享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中。 ES6实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class FlyweightFactory &#123; constructor() &#123; this.flyweights = &#123;&#125;; console.log('FlyweightFactory Class created'); &#125; getFlyweight(key) &#123; console.log('FlyweightFactory.getFlyweight invoked'); if (this.flyweights[key]) &#123; return this.flyweights[key]; &#125; else &#123; this.flyweights[key] = new ConcreteFlyweight(key); return this.flyweights[key]; &#125; &#125; createGibberish(keys) &#123; console.log('FlyweightFactory.createGibberish invoked'); return new UnsharedConcreteFlyweight(keys, this); &#125;&#125;class Flyweight &#123; constructor() &#123; console.log('Flyweight Class created'); &#125; operation(extrinsicState) &#123; console.log('Flyweight.operation invoked'); &#125;&#125;class ConcreteFlyweight extends Flyweight &#123; constructor(key) &#123; super(); this.intrinsicState = key; console.log('ConcreteFlyweight Class created'); &#125; operation(extrinsicState) &#123; console.log('ConcreteFlyweight.operation invoked'); return extrinsicState + this.intrinsicState; &#125;&#125;class UnsharedConcreteFlyweight extends Flyweight &#123; constructor(keys, flyweights) &#123; super(); this.flyweights = flyweights; this.keys = keys; console.log('UnsharedConcreteFlyweight Class created'); &#125; operation(extrinsicState) &#123; console.log('UnsharedConcreteFlyweight.operation invoked'); var key, word = ''; for (var i = 0; i &lt; extrinsicState; i++) &#123; key = this.keys[Math.floor(Math.random() * (this.keys.length))]; word = this.flyweights.getFlyweight(key).operation(word); &#125; console.log('UnsharedConcreteFlyweight Operation: '); console.log(word); &#125;&#125;var flyweights = new FlyweightFactory();var gibberish = flyweights.createGibberish(['-', '+', '*']);gibberish.operation(5); Typescript实现123456789101112131415161718192021222324252627282930313233343536373839404142434445namespace FlyweightPattern &#123; export interface Flyweight &#123; operation(s: String): void; &#125; export class ConcreteFlyweight implements Flyweight &#123; private instrinsicState: String; constructor(instrinsicState: String) &#123; this.instrinsicState = instrinsicState; &#125; public operation(s: String): void &#123; console.log("`operation` of ConcreteFlyweight", s, " is being called!"); &#125; &#125; export class UnsharedConcreteFlyweight implements Flyweight &#123; private allState: number; constructor(allState: number) &#123; this.allState = allState; &#125; public operation(s: String): void &#123; console.log("`operation` of UnsharedConcreteFlyweight", s, " is being called!"); &#125; &#125; export class FlyweightFactory &#123; private fliesMap: &#123; [s: string]: Flyweight; &#125; = &lt;any&gt;&#123;&#125;; constructor() &#123; &#125; public getFlyweight(key: string): Flyweight &#123; if (this.fliesMap[key] === undefined || null) &#123; this.fliesMap[key] = new ConcreteFlyweight(key); &#125; return this.fliesMap[key]; &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Structural Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>享元模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解析器模式(Interpreter)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FInterpreter%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 解析器模式的定义 解析器模式：在外观模式中，外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面， 外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。 解析器模式包含二个角色： Interpreter-外观角色是在客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理； SubSystem-在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能 ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class Context &#123; constructor(input) &#123; this.sum = 0; this.list = []; console.log('Context Class created'); &#125; add(eps) &#123; console.log('Context.add invoked'); this.list.push(eps); &#125; getList() &#123; console.log('Context.getList invoked'); return this.list; &#125; getSum() &#123; console.log('Context.getSum invoked'); return this.sum; &#125; setSum(_sum) &#123; this.sum = _sum; console.log('Context.setSum invoked'); &#125;&#125;class AbstractExpression &#123; constructor() &#123; console.log('AbstractExpression Class created'); &#125; interpret(context) &#123; console.log('AbstractExpression.interpret invoked'); &#125;&#125;class PlusExpression extends AbstractExpression &#123; constructor(name) &#123; super(); this.name = name; console.log('PlusExpression Class created'); &#125; interpret(context) &#123; console.log('PlusExpression.interpret invoked'); var sum = context.getSum(); sum++; context.setSum(sum); &#125;&#125;class MinusExpression extends AbstractExpression &#123; constructor() &#123; super(); this.name = '+'; console.log('MinusExpression Class created'); &#125; interpret(context) &#123; console.log('MinusExpression.interpret invoked'); var sum = context.getSum(); sum--; context.setSum(sum) &#125;&#125;var context = new Context();context.setSum(20);context.add(new PlusExpression());context.add(new PlusExpression());context.add(new PlusExpression());context.add(new MinusExpression());context.add(new MinusExpression());var list = context.getList();for (var i = 0; i &lt; list.length; i++) &#123; var expression = list[i]; expression.interpret(context);&#125;console.log("Result：" + context.getSum()); Typescript实现123456789101112131415161718192021namespace InterpreterPattern &#123; export class Context &#123; &#125; export interface AbstractExpression &#123; interpret(context: Context): void; &#125; export class TerminalExpression implements AbstractExpression &#123; public interpret(context: Context): void &#123; console.log("`interpret` method of TerminalExpression is being called!"); &#125; &#125; export class NonterminalExpression implements AbstractExpression &#123; public interpret(context: Context): void &#123; console.log("`interpret` method of NonterminalExpression is being called!"); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Behavioral Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>解析器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器(Iterator)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FIterator%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 ES6实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Iterator &#123; constructor() &#123; console.log('Iterator Class created'); &#125; first() &#123; console.log('Iterator.first invoked'); &#125; next() &#123; console.log('Iterator.next invoked'); &#125; isDone() &#123; console.log('Iterator.isDone invoked'); &#125; currentItem() &#123; console.log('Iterator.currentItem invoked'); &#125;&#125;class ConcreteIterator extends Iterator &#123; constructor(aggregate) &#123; super(); this.index = 0; this.aggregate = aggregate; console.log('ConcreteIterator Class created'); &#125; first() &#123; console.log('ConcreteIterator.first invoked'); return this.aggregate.list[0]; &#125; next() &#123; console.log('ConcreteIterator.next invoked'); this.index += 1; return this.aggregate.list[this.index]; &#125; currentItem() &#123; console.log('ConcreteIterator.currentItem invoked'); return this.aggregate.list[this.index]; &#125;&#125;class Aggregate &#123; constructor() &#123; console.log('Aggregate Class created'); &#125; createIterator() &#123; console.log('Aggregate.CreateIterator invoked'); &#125;&#125;class ConcreteAggregate extends Aggregate &#123; constructor(list) &#123; super(); this.list = list; console.log('ConcreteAggregate Class created'); &#125; createIterator() &#123; console.log('ConcreteAggregate.CreateIterator invoked'); this.iterator = new ConcreteIterator(this); &#125;&#125;var aggregate = new ConcreteAggregate([0, 1, 2, 3, 4, 5, 6, 7]);aggregate.createIterator();console.log(aggregate.iterator.first());console.log(aggregate.iterator.next());console.log(aggregate.iterator.currentItem()); Typescript实现123456789101112131415namespace IteratorPattern &#123; export namespace Demo &#123; export function show() : void &#123; var nArray = [1, 7, 21, 657, 3, 2, 765, 13, 65], numbers: IteratorPattern.Numbers = new IteratorPattern.Numbers(nArray), it: IteratorPattern.ConcreteIterator = &lt;IteratorPattern.ConcreteIterator&gt;numbers.createIterator(); while (it.hasNext()) &#123; console.log(it.next()); &#125; &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Behavioral Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式(Observer)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FObserver%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 观察者模式的定义 观察者模式定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。 观察者模式又叫做发布-订阅模式、模型-视图模式、源-监听器模式或从属者模式。 观察者模式是一种对象行为型模式。 观察者模式包含四个角色： Subject-目标又称为主题，它是指被观察的对象； ConcreteSubject-具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知； Observer-观察者将对观察目标的改变做出反应； ConcreteObserver-在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。 ES6实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Subject &#123; constructor() &#123; console.log('Subject Class created'); &#125; attach(observer) &#123; this.observers.push(observer); console.log('Subject.attach invoked'); &#125; dettach(observer) &#123; console.log('Subject.dettach invoked'); for (var i in this.observers) &#123; if (this.observers[i] === observer) &#123; this.observers.splice(i, 1); &#125; &#125; &#125; notify() &#123; console.log('Subject.notify invoked'); for (var i in this.observers) &#123; this.observers[i].update(this); &#125; &#125;&#125;class ConcreteSubject extends Subject &#123; constructor() &#123; super(); this.subjectState = null; this.observers = []; console.log('ConcreteSubject Class created'); &#125; getState() &#123; console.log('ConcreteSubject.getState invoked'); return this.subjectState; &#125; setState(state) &#123; console.log('ConcreteSubject.setState invoked'); this.subjectState = state; this.notify(); &#125;&#125;class Observer &#123; constructor() &#123; console.log('Observer Class created'); &#125; update() &#123; console.log('Observer.update invoked'); &#125;&#125;class ConcreteObserver extends Observer &#123; constructor() &#123; super(); this.observerState = ''; console.log('ConcreteObserver Class created'); &#125; update(Subject) &#123; console.log('ConcreteObserver.update invoked'); this.observerState = Subject.getState(); console.log('Observer new state: ' + this.observerState); &#125;&#125;var observer1 = new ConcreteObserver();var observer2 = new ConcreteObserver();var subject = new ConcreteSubject();subject.attach(observer1);subject.attach(observer2);subject.setState('state 1'); Typescript实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071namespace ObserverPattern &#123; export class Subject &#123; private observers: Observer[] = []; public register(observer: Observer): void &#123; console.log(observer, "is pushed!"); this.observers.push(observer); &#125; public unregister(observer: Observer): void &#123; var n: number = this.observers.indexOf(observer); console.log(observer, "is removed"); this.observers.splice(n, 1); &#125; public notify(): void &#123; console.log("notify all the observers", this.observers); var i: number , max: number; for (i = 0, max = this.observers.length; i &lt; max; i += 1) &#123; this.observers[i].notify(); &#125; &#125; &#125; export class ConcreteSubject extends Subject &#123; private subjectState: number; get SubjectState(): number &#123; return this.subjectState; &#125; set SubjectState(subjectState: number) &#123; this.subjectState = subjectState; &#125; &#125; export class Observer &#123; public notify(): void &#123; throw new Error("Abstract Method!"); &#125; &#125; export class ConcreteObserver extends Observer &#123; private name: string; private state: number; private subject: ConcreteSubject; constructor (subject: ConcreteSubject, name: string) &#123; super(); console.log("ConcreteObserver", name, "is created!"); this.subject = subject; this.name = name; &#125; public notify(): void &#123; console.log("ConcreteObserver's notify method"); console.log(this.name, this.state); this.state = this.subject.SubjectState; &#125; get Subject(): ConcreteSubject &#123; return this.subject; &#125; set Subject(subject: ConcreteSubject) &#123; this.subject = subject; &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Behavioral Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桥接模式(Bridge)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FBridge%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 桥接模式的定义 桥接模式：模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。 桥接模式包含四个角色： Abstraction-抽象类中定义了一个实现类接口类型的对象并可以维护该对象； RefinedAbstraction-扩充抽象类扩充由抽象类定义的接口，它实现了在抽象类中定义的抽象业务方法，在扩充抽象类中可以调用在实现类接口中定义的业务方法； Implementor实现类接口定义了实现类的接口，实现类接口仅提供基本操作，而抽象类定义的接口可能会做更多更复杂的操作； ConcreteImplementor具体实现类实现了实现类接口并且具体实现它，在不同的具体实现类中提供基本操作的不同实现，在程序运行时，具体实现类对象将替换其父类对象，提供给客户端具体的业务操作方法。 ES6实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Abstraction &#123; constructor() &#123; console.log('Abstraction Class created'); &#125; operation() &#123; console.log('Abstraction.operation invoked'); this.imp.operationImp(); &#125;&#125;class RefinedAbstraction extends Abstraction &#123; constructor() &#123; super() console.log('RefinedAbstraction Class created'); &#125; setImp(imp) &#123; console.log('RefinedAbstraction.setImp invoked'); this.imp = imp &#125;&#125;class Implementor &#123; constructor() &#123; console.log('Implementor Class created'); &#125; operationImp() &#123; console.log('Implementor.operationImp invoked'); &#125;&#125;class ConcreteImplementorA extends Implementor &#123; constructor() &#123; super() console.log('ConcreteImplementorA Class created'); &#125; operationImp() &#123; console.log('ConcreteImplementorA.operationImp invoked'); &#125;&#125;class ConcreteImplementorB extends Implementor &#123; constructor() &#123; super() console.log('ConcreteImplementorB Class created'); &#125; operationImp() &#123; console.log('ConcreteImplementorB.operationImp invoked'); &#125;&#125;var abstraction = new RefinedAbstraction();abstraction.setImp(new ConcreteImplementorA());abstraction.operation();abstraction.setImp(new ConcreteImplementorB());abstraction.operation(); Typescript实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Abstraction &#123; constructor() &#123; console.log('Abstraction Class created'); &#125; operation() &#123; console.log('Abstraction.operation invoked'); this.imp.operationImp(); &#125;&#125;class RefinedAbstraction extends Abstraction &#123; constructor() &#123; super() console.log('RefinedAbstraction Class created'); &#125; setImp(imp) &#123; console.log('RefinedAbstraction.setImp invoked'); this.imp = imp &#125;&#125;class Implementor &#123; constructor() &#123; console.log('Implementor Class created'); &#125; operationImp() &#123; console.log('Implementor.operationImp invoked'); &#125;&#125;class ConcreteImplementorA extends Implementor &#123; constructor() &#123; super() console.log('ConcreteImplementorA Class created'); &#125; operationImp() &#123; console.log('ConcreteImplementorA.operationImp invoked'); &#125;&#125;class ConcreteImplementorB extends Implementor &#123; constructor() &#123; super() console.log('ConcreteImplementorB Class created'); &#125; operationImp() &#123; console.log('ConcreteImplementorB.operationImp invoked'); &#125;&#125;var abstraction = new RefinedAbstraction();abstraction.setImp(new ConcreteImplementorA());abstraction.operation();abstraction.setImp(new ConcreteImplementorB());abstraction.operation(); 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Structural Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>桥接模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式(Prototype)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FPrototype%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Prototype &#123; constructor(prototype) &#123; console.log("Prototype Class created"); &#125; setFeature(key, val) &#123; this[key] = val &#125; clone() &#123; console.log("Prototype.clone invoked"); &#125;&#125;class ConcretePrototype1 extends Prototype &#123; constructor() &#123; super(); console.log("ConcretePrototype1 created"); this.feature = "feature 1" &#125; clone() &#123; console.log('ConcretePrototype1.clone invoked'); let clone = new ConcretePrototype1(); let keys = Object.keys(this); keys.forEach(k =&gt; clone.setFeature(k, this[k])); console.log("ConcretePrototype1 cloned"); return clone; &#125;&#125;class ConcretePrototype2 extends Prototype &#123; constructor() &#123; super(); console.log("ConcretePrototype2 created"); this.feature = "feature 2" &#125; clone() &#123; console.log('ConcretePrototype2.Clone function'); let clone = new ConcretePrototype2(); let keys = Object.keys(this); keys.forEach(k =&gt; clone.setFeature(k, this[k])); console.log("ConcretePrototype2 cloned"); return clone; &#125;&#125;var proto1 = new ConcretePrototype1();proto1.setFeature('feature', "feature 11");var clone1 = proto1.clone();console.log(clone1.feature);console.log(typeof clone1);console.log(clone1 === proto1);var proto2 = new ConcretePrototype2();proto2.setFeature('feature', "feature 22");var clone2 = proto2.clone();console.log(clone2.feature);console.log(typeof clone2);console.log(clone2 === proto2); Typescript实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455namespace PrototypePattern &#123; export interface Prototype &#123; clone(): Prototype; toString(): string; &#125; export class Concrete1 implements Prototype &#123; clone() : Prototype &#123; return new Concrete1(); &#125; toString(): string &#123; return "This is Concrete1"; &#125; &#125; export class Concrete2 implements Prototype &#123; clone() : Prototype &#123; return new Concrete2(); &#125; toString(): string &#123; return "This is Concrete2"; &#125; &#125; export class Concrete3 implements Prototype &#123; clone() : Prototype &#123; return new Concrete3(); &#125; toString(): string &#123; return "This is Concrete3"; &#125; &#125; export class Builder &#123; private prototypeMap: &#123; [s: string]: Prototype; &#125; = &#123;&#125;; constructor() &#123; this.prototypeMap['c1'] = new Concrete1(); this.prototypeMap['c2'] = new Concrete2(); this.prototypeMap['c3'] = new Concrete3(); &#125; createOne(s: string): Prototype &#123; console.log(s); return this.prototypeMap[s].clone(); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Creational Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式(Proxy)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FProxy%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 代理模式的定义 代理模式(Proxy Pattern) ：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英 文叫做Proxy或Surrogate，它是一种对象结构型模式。 代理模式包含三个角色：Subject: 抽象主题角色Proxy: 代理主题角色RealSubject: 真实主题角色 ES6实现1234567891011121314151617181920212223242526272829303132333435class Subject &#123; constructor() &#123; console.log('Subject Class created'); &#125; request() &#123; console.log('Subject.request invoked'); &#125;&#125;class RealSubject extends Subject &#123; constructor() &#123; super() console.log('RealSubject Class created'); &#125; request() &#123; console.log('RealSubject.request invoked'); &#125;&#125;class Proxy extends Subject &#123; constructor() &#123; super() console.log('Proxy Class created'); &#125; request() &#123; this.realSubject = new RealSubject(); this.realSubject.request(); &#125;&#125;var proxy = new Proxy()proxy.request() Typescript实现12345678910111213141516171819202122232425262728293031323334namespace ProxyPattern &#123; export interface Subject &#123; doAction(): void; &#125; export class Proxy implements Subject &#123; private realSubject: RealSubject; private s: string; constructor(s: string) &#123; this.s = s; &#125; public doAction(): void &#123; console.log("`doAction` of Proxy(", this.s, ")"); if (this.realSubject === null || this.realSubject === undefined) &#123; console.log("creating a new RealSubject."); this.realSubject = new RealSubject(this.s); &#125; this.realSubject.doAction(); &#125; &#125; export class RealSubject implements Subject &#123; private s: string; constructor(s: string) &#123; this.s = s; &#125; public doAction(): void &#123; console.log("`doAction` of RealSubject", this.s, "is being called!"); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Structural Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者模式(Builder)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FBuilder%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 建造者模式包含如下四个角色： Builder-抽象建造者为创建一个产品对象的各个部件指定抽象接口； ConcreteBuilder-具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象； Product-产品角色是被构建的复杂对象，包含多个组成部件； Director-指挥者负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造 建造者模式的结构中引入了一个指挥者类，该类的作用主要有两个： 一方面它隔离了客户与生产过程； 另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。 ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Builder &#123; constructor() &#123; console.log('Builder Class created!'); &#125; buildPart(partName) &#123; console.log('Builder.buildPart invoked!'); &#125;&#125;class ConcreteBuilder extends Builder &#123; constructor() &#123; super(); console.log('ConcreteBuilder Class created!'); &#125; buildPart(partName) &#123; super.buildPart(partName); console.log('ConcreteBuilder.buildPart invoked!'); this.product = new Product(partName); &#125; getResult() &#123; console.log('ConcreteBuilder.getResult invoked!'); return this.product; &#125;&#125;class Product &#123; constructor(material) &#123; console.log("Product class created"); this.data = material &#125;&#125;class Director &#123; constructor() &#123; this.structure = ['Prod1', 'Prod2', 'Prod3']; console.log("Director class created"); &#125; construct() &#123; console.log("Director.Construct created"); for (var prodName in this.structure) &#123; let builder = new ConcreteBuilder(); builder.buildPart(this.structure[prodName]); builder.getResult(); &#125; &#125;&#125;let director = new Director();director.construct(); Typescript实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869namespace BuilderPattern &#123; export class UserBuilder &#123; private name: string; private age: number; private phone: string; private address: string; constructor(name: string) &#123; this.name = name; &#125; get Name() &#123; return this.name; &#125; setAge(value: number): UserBuilder &#123; this.age = value; return this; &#125; get Age() &#123; return this.age; &#125; setPhone(value: string): UserBuilder &#123; this.phone = value; return this; &#125; get Phone() &#123; return this.phone; &#125; setAddress(value: string): UserBuilder &#123; this.address = value; return this; &#125; get Address() &#123; return this.address; &#125; build(): User &#123; return new User(this); &#125; &#125; export class User &#123; private name: string; private age: number; private phone: string; private address: string; constructor(builder: UserBuilder) &#123; this.name = builder.Name; this.age = builder.Age; this.phone = builder.Phone; this.address = builder.Address &#125; get Name() &#123; return this.name; &#125; get Age() &#123; return this.age; &#125; get Phone() &#123; return this.phone; &#125; get Address() &#123; return this.address; &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Creational Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>建造者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式(Singleton)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FSingleton%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 单例模式的定义 某个类只能有一个实例； 它必须自行创建这个实例； 它必须自行向整个系统提供这个实例。 单例模式的实现过程中，需要注意如下三点： 单例类的构造函数为私有； 提供一个自身的静态私有成员变量； 提供一个公有的静态工厂方法。 ES6实现1234567891011121314class Singleton &#123; constructor(data) &#123; if (Singleton.prototype.Instance === undefined) &#123; this.data = data; Singleton.prototype.Instance = this; &#125; return Singleton.prototype.Instance; &#125;&#125;let ob1 = new Singleton.getInstance();let ob2 = new Singleton("two");console.log(ob1 === ob2); Typescript实现12345678910111213141516class Singleton &#123; private static instance: Singleton; constructor() &#123;&#125; static get Instance() &#123; if (this.instance === null || this.instance === undefined) &#123; this.instance = new Singleton(); &#125; return this.instance; &#125;&#125;let ob1 = new Singleton("one");let ob2 = new Singleton("two");console.log(ob1 === ob2); 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Creational Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单工厂模式(Factory)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FSimpleFactory%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 简单工厂模式的定义 简单工厂模式：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。 简单工厂模式包含三个角色： Factory-工厂角色负责实现创建所有实例的内部逻辑； Product-抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口； ConcreteProduct-具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。 ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243class Product &#123; constructor() &#123; console.log('Product Class created'); &#125;&#125;class ConcreteProduct extends Product &#123; constructor() &#123; super(); console.log('ConcreteProduct Class created'); &#125;&#125;class Creator &#123; constructor() &#123; console.log('Creator Class created'); &#125; factoryMethod() &#123; console.log('Creator.factoryMethod created'); &#125; anOperation() &#123; console.log('Creator.anOperation created'); this.product = this.factoryMethod(); console.log(this.product instanceof ConcreteProduct); &#125;&#125;class ConcreteCreator extends Creator &#123; constructor() &#123; super(); console.log('ConcreteCreator Class created'); &#125; factoryMethod() &#123; return new ConcreteProduct(); &#125;&#125;var factory = new ConcreteCreator();factory.anOperation(); Typescript实现123456789101112131415161718192021222324252627interface AbstractProduct &#123; method(param?: any) : void;&#125;class ConcreteProductA implements AbstractProduct &#123; method = (param?: any) =&gt; &#123; return "Method of ConcreteProductA"; &#125;&#125;class ConcreteProductB implements AbstractProduct &#123; method = (param?: any) =&gt; &#123; return "Method of ConcreteProductB"; &#125;&#125;class ProductFactory &#123; public static createProduct(type: string) : AbstractProduct &#123; if (type === "A") &#123; return new ConcreteProductA(); &#125; else if (type === "B") &#123; return new ConcreteProductB(); &#125; return null; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Creational Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态模式(State)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FState%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 状态模式的定义 状态模式允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。 其别名为状态对象，状态模式是一种对象行为型模式。 状态模式包含二个角色： Context-环境类又称为上下文类，它是拥有状态的对象，在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象，可以定义初始状态； State-抽象状态类用于定义一个接口以封装与环境类的一个特定状态相关的行为； ConcreteState-具体状态类是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。 ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Context &#123; constructor(state) &#123; console.log("Context Class created"); switch (state) &#123; case "A": this.state = new ConcreteStateA() break case "B": this.state = new ConcreteStateB() break default: this.state = new ConcreteStateA() &#125; &#125; request() &#123; console.log('Context.request invoked'); this.state.handle(this); &#125;&#125;class State &#123; constructor() &#123; console.log("State Class created"); &#125; handle() &#123; console.log('State.handle invoked'); &#125;&#125;class ConcreteStateA extends State &#123; constructor() &#123; super(); console.log("ConcreteStateA Class created"); &#125; handle(context) &#123; console.log('ConcreteStateA.handle invoked'); &#125;&#125;class ConcreteStateB extends State &#123; constructor() &#123; super(); console.log("ConcreteStateB Class created"); &#125; handle(context) &#123; console.log('ConcreteStateB.handle invoked'); &#125;&#125;let context = new Context("A")context.request() Typescript实现12345678910111213141516171819202122232425262728293031323334353637383940namespace StatePattern &#123; export interface State &#123; handle(context: Context): void; &#125; export class ConcreteStateA implements State &#123; public handle(context: Context): void &#123; console.log("`handle` method of ConcreteStateA is being called!"); context.State = new ConcreteStateB(); &#125; &#125; export class ConcreteStateB implements State &#123; public handle(context: Context): void &#123; console.log("`handle` method of ConcreteStateB is being called!"); context.State = new ConcreteStateA(); &#125; &#125; export class Context &#123; private state: State; constructor(state: State) &#123; this.state = state; &#125; get State(): State &#123; return this.state; &#125; set State(state: State) &#123; this.state = state; &#125; public request(): void &#123; console.log("request is being called!"); this.state.handle(this); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Behavioral Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>状态模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式(Strategy)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FStrategy%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 策略模式的定义 策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。 策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。。 策略模式包含三个角色： Context-环境类在解决某个问题时可以采用多种策略，在环境类中维护一个对抽象策略类的引用实例; Strategy-抽象策略类为所支持的算法声明了抽象方法，是所有策略类的父类; ConcreteStrategy-具体策略类实现了在抽象策略类中定义的算法。 ES6实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Context &#123; constructor(type) &#123; console.log('Context Class created!'); switch (type) &#123; case "A": this.strategy = new ConcreteStrategyA() break case "B": this.strategy = new ConcreteStrategyB() break default: this.strategy = new ConcreteStrategyA() &#125; &#125; contextInterface() &#123; console.log('Context.contextInterface invoked'); this.strategy.algorithmInterface() &#125;&#125;class Strategy &#123; constructor() &#123; console.log('Strategy Class created!'); &#125; algorithmInterface() &#123; console.log('Strategy.algorithmInterface invoked'); &#125;&#125;class ConcreteStrategyA extends Strategy &#123; constructor() &#123; super(); console.log('ConcreteStrategyA Class created!'); &#125; algorithmInterface() &#123; console.log('ConcreteStrategyA.algorithmInterface invoked'); &#125;&#125;class ConcreteStrategyB extends Strategy &#123; constructor() &#123; super(); console.log('ConcreteStrategyB Class created!'); &#125; algorithmInterface() &#123; console.log('ConcreteStrategyB.algorithmInterface invoked'); &#125;&#125;let contextA = new Context("A");contextA.contextInterface();let contextB = new Context("B");contextB.contextInterface(); Typescript实现1234567891011121314151617181920212223242526272829303132333435namespace StrategyPattern &#123; export interface Strategy &#123; execute(): void; &#125; export class ConcreteStrategy1 implements Strategy &#123; public execute(): void &#123; console.log("`execute` method of ConcreteStrategy1 is being called"); &#125; &#125; export class ConcreteStrategy2 implements Strategy &#123; public execute(): void &#123; console.log("`execute` method of ConcreteStrategy2 is being called"); &#125; &#125; export class ConcreteStrategy3 implements Strategy &#123; public execute(): void &#123; console.log("`execute` method of ConcreteStrategy3 is being called"); &#125; &#125; export class Context &#123; private strategy: Strategy; constructor(strategy: Strategy) &#123; this.strategy = strategy; &#125; public executeStrategy(): void &#123; this.strategy.execute(); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Behavioral Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板方法模式(TemplateMethod)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FTemplateMethod%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 模板方法模式的定义 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 ES6实现12345678910111213141516171819202122232425262728293031323334353637class AbstractClass &#123; constructor() &#123; console.log('AbstractClass Class created!'); &#125; templateMethod() &#123; console.log('AbstractClass.templateMethod invoked'); this.primitiveOperation1(); this.primitiveOperation2(); &#125; primitiveOperation1() &#123; console.log('AbstractClass.primitiveOperation1 invoked'); &#125; primitiveOperation2() &#123; console.log('AbstractClass.primitiveOperation2 invoked'); &#125;&#125;class ConcreteClass extends AbstractClass &#123; constructor() &#123; super(); console.log('ConcreteClass Class created!'); &#125; primitiveOperation1() &#123; console.log('ConcreteClass.primitiveOperation1 invoked'); &#125; primitiveOperation2() &#123; console.log('ConcreteClass.primitiveOperation2 invoked'); &#125;&#125;let obj = new ConcreteClass();obj.templateMethod(); Typescript实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950namespace TemplateMethodPattern &#123; export class AbstractClass &#123; public method1(): void &#123; throw new Error("Abstract Method"); &#125; public method2(): void &#123; throw new Error("Abstract Method"); &#125; public method3(): void &#123; throw new Error("Abstract Method"); &#125; public templateMethod(): void &#123; console.log("templateMethod is being called"); this.method1(); this.method2(); this.method3(); &#125; &#125; export class ConcreteClass1 extends AbstractClass &#123; public method1(): void &#123; console.log("method1 of ConcreteClass1"); &#125; public method2(): void &#123; console.log("method2 of ConcreteClass1"); &#125; public method3(): void &#123; console.log("method3 of ConcreteClass1"); &#125; &#125; export class ConcreteClass2 extends AbstractClass &#123; public method1(): void &#123; console.log("method1 of ConcreteClass2"); &#125; public method2(): void &#123; console.log("method2 of ConcreteClass2"); &#125; public method3(): void &#123; console.log("method3 of ConcreteClass2"); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Behavioral Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>模板方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[访问者模式(Visitor)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FVisitor%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 访问者模式的定义 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 ES6实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798class Visitor &#123; constructor() &#123; console.log('Visitor Class created!'); &#125; visitConcreteElementA(ConcreteElementA) &#123; console.log('Visitor.visitConcreteElementA invoked'); &#125; visitConcreteElementB(ConcreteElementB) &#123; console.log('Visitor.visitConcreteElementB invoked'); &#125;&#125;class ConcreteVisitor1 extends Visitor &#123; constructor() &#123; super(); console.log('ConcreteVisitor1 Class created!'); &#125; visitConcreteElementA(ConcreteElementA) &#123; console.log('ConcreteVisitor1.visitConcreteElementA invoked'); &#125; visitConcreteElementB(ConcreteElementB) &#123; console.log('ConcreteVisitor1.visitConcreteElementB invoked'); &#125;&#125;class ConcreteVisitor2 extends Visitor &#123; constructor() &#123; super(); console.log('ConcreteVisitor2 Class created!'); &#125; visitConcreteElementA(ConcreteElementA) &#123; console.log('ConcreteVisitor2.visitConcreteElementA invoked'); &#125; visitConcreteElementB(ConcreteElementB) &#123; console.log('ConcreteVisitor2.visitConcreteElementB invoked'); &#125;&#125;class ObjectStructure &#123; constructor() &#123; console.log('ObjectStructure Class created!'); &#125;&#125;class Element &#123; constructor() &#123; console.log('Element Class created!'); &#125; Accept(visitor) &#123; console.log('Element.visitConcreteElementB invoked'); &#125;&#125;class ConcreteElementA extends Element &#123; constructor() &#123; super(); console.log('ConcreteElementA Class created!'); &#125; accept(visitor) &#123; console.log('ConcreteElementA.accept invoked'); visitor.visitConcreteElementA(this); &#125; operationA() &#123; console.log('ConcreteElementA.operationA invoked'); &#125;&#125;class ConcreteElementB extends Element &#123; constructor() &#123; super(); console.log('ConcreteElementB Class created!'); &#125; accept(visitor) &#123; console.log('ConcreteElementB.accept invoked'); visitor.visitConcreteElementB(this); &#125; operationB() &#123; console.log('ConcreteElementB.operationB invoked'); &#125;&#125;let visitor1 = new ConcreteVisitor1();let visitor2 = new ConcreteVisitor2();let elementA = new ConcreteElementA();let elementB = new ConcreteElementB();elementA.accept(visitor1);elementB.accept(visitor2); Typescript实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768namespace VisitorPattern &#123; export interface Visitor &#123; visitConcreteElement1(concreteElement1: ConcreteElement1): void; visitConcreteElement2(concreteElement2: ConcreteElement2): void; &#125; export class ConcreteVisitor1 implements Visitor &#123; public visitConcreteElement1(concreteElement1: ConcreteElement1): void &#123; console.log("`visitConcreteElement1` of ConcreteVisitor1 is being called!"); &#125; public visitConcreteElement2(concreteElement2: ConcreteElement2): void &#123; console.log("`visitConcreteElement2` of ConcreteVisitor1 is being called!"); &#125; &#125; export class ConcreteVisitor2 implements Visitor &#123; public visitConcreteElement1(concreteElement1: ConcreteElement1): void &#123; console.log("`visitConcreteElement1` of ConcreteVisitor2 is being called!"); &#125; public visitConcreteElement2(concreteElement2: ConcreteElement2): void &#123; console.log("`visitConcreteElement2` of ConcreteVisitor2 is being called!"); &#125; &#125; export interface Element &#123; operate(visitor: Visitor): void; &#125; export class ConcreteElement1 implements Element &#123; public operate(visitor: Visitor): void &#123; console.log("`operate` of ConcreteElement1 is being called!"); visitor.visitConcreteElement1(this); &#125; &#125; export class ConcreteElement2 implements Element &#123; public operate(visitor: Visitor): void &#123; console.log("`operate` of ConcreteElement2 is being called!"); visitor.visitConcreteElement2(this); &#125; &#125; export class Objs &#123; private elements: Element[] = []; public attach(e: Element): void &#123; this.elements.push(e); &#125; public detach(e: Element): void &#123; var index = this.elements.indexOf(e); this.elements.splice(index, 1); &#125; public operate(visitor: Visitor): void &#123; var i = 0, max = this.elements.length; for(; i &lt; max; i += 1) &#123; this.elements[i].operate(visitor); &#125; &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Behavioral Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>访问者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[责任链模式(Chain of Responsibility)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FchainOfResponsibility%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849'use strict';class Handler &#123; constructor() &#123; console.log('Handler Class created'); &#125; handleRequest() &#123; console.log('Handler.handleRequest invoked'); &#125;&#125;class ConcreteHandler1 extends Handler &#123; constructor() &#123; super(); console.log('ConcreteHandler1 Class created'); &#125; setSuccessor(successor) &#123; this.successor = successor; console.log('ConcreteHandler1.setSuccessor invoked'); &#125; handleRequest(request) &#123; console.log('ConcreteHandler1.handleRequest invoked'); if (request === 'run') console.log('ConcreteHandler1 has handled the request'); else &#123; console.log('ConcreteHandler1 calls his successor'); this.successor.handleRequest(request); &#125; &#125;&#125;class ConcreteHandler2 extends Handler &#123; constructor() &#123; super(); console.log('ConcreteHandler2 Class created'); &#125; handleRequest(request) &#123; console.log('ConcreteHandler2.handleRequest invoked'); &#125;&#125;let handle1 = new ConcreteHandler1();let handle2 = new ConcreteHandler2();handle1.setSuccessor(handle2);handle1.handleRequest('run');handle1.handleRequest('stay'); Typescript实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455namespace ChainOfResponsibilityPattern &#123; export class Handler &#123; private handler: Handler; private req: number; constructor(req: number) &#123; this.req = req; &#125; public setHandler(handler: Handler): void &#123; this.handler = handler; &#125; public operation(msg: string, req: number): void &#123; if (req &lt;= this.req) &#123; this.handlerRequest(msg) &#125; else if (this.handler !== null &amp;&amp; this.handler !== undefined) &#123; this.handler.operation(msg, req); &#125; &#125; public handlerRequest(msg: string): void &#123; throw new Error("Abstract method!"); &#125; &#125; export class ConcreteHandler1 extends Handler &#123; constructor(req: number) &#123; super(req); &#125; public handlerRequest(msg: string) &#123; console.log("Message (ConcreteHandler1) :: ", msg); &#125; &#125; export class ConcreteHandler2 extends Handler &#123; constructor(req: number) &#123; super(req); &#125; public handlerRequest(msg: string) &#123; console.log("Message :: (ConcreteHandler2) ", msg); &#125; &#125; export class ConcreteHandler3 extends Handler &#123; constructor(req: number) &#123; super(req); &#125; public handlerRequest(msg: string) &#123; console.log("Message :: (ConcreteHandler3) ", msg); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Behavioral Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>责任链模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令模式(Command)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FCommand%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 命令模式的定义 命令模式：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化； 对请求排队或者记录请求日志，以及支持可撤销的操作。 命令模式是一种对象行为型模式，其别名为动作模式或事务模式。 命令模式包含四个角色： Command-抽象命令类中声明了用于执行请求等方法，通过这些方法可以调用请求接收者的相关操作； ConcreteCommand-具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中； Invoker-调用者即请求的发送者，又称为请求者，它通过命令对象来执行请求； Receiver-接收者执行与请求相关的操作，它具体实现对请求的业务处理。 ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Invoker &#123; constructor() &#123; console.log('Invoker Class created'); &#125; storeCommand(command) &#123; this.command = command; console.log('Invoker.storeCommand invoked'); &#125;&#125;class Command &#123; constructor() &#123; console.log('Command Class created'); &#125; execute() &#123; console.log('Command.execute invoked'); &#125;&#125;class ConcreteCommand extends Command &#123; constructor(receiver, state) &#123; super(); this.receiver = receiver; console.log('ConcreteCommand Class created'); &#125; execute() &#123; console.log('ConcreteCommand.execute invoked'); this.receiver.action(); &#125;&#125;class Receiver &#123; constructor() &#123; console.log('Receiver Class created'); &#125; action() &#123; console.log('Receiver.action invoked'); &#125;&#125;var invoker = new Invoker();var receiver = new Receiver();var command = new ConcreteCommand(receiver);invoker.storeCommand(command);invoker.command.execute(); Typescript实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465namespace CommandPattern &#123; export class Command &#123; public execute(): void &#123; throw new Error("Abstract method!"); &#125; &#125; export class ConcreteCommand1 extends Command &#123; private receiver: Receiver; constructor(receiver: Receiver) &#123; super(); this.receiver = receiver; &#125; public execute(): void &#123; console.log("`execute` method of ConcreteCommand1 is being called!"); this.receiver.action(); &#125; &#125; export class ConcreteCommand2 extends Command &#123; private receiver: Receiver; constructor(receiver: Receiver) &#123; super(); this.receiver = receiver; &#125; public execute(): void &#123; console.log("`execute` method of ConcreteCommand2 is being called!"); this.receiver.action(); &#125; &#125; export class Invoker &#123; private commands: Command[]; constructor() &#123; this.commands = []; &#125; public storeAndExecute(cmd: Command) &#123; this.commands.push(cmd); cmd.execute(); &#125; &#125; export class Receiver &#123; public action(): void &#123; console.log("action is being called!"); &#125; &#125;&#125;(function main() &#123; var receiver: CommandPattern.Receiver = new CommandPattern.Receiver(), command1: CommandPattern.Command = new CommandPattern.ConcreteCommand1(receiver), command2: CommandPattern.Command = new CommandPattern.ConcreteCommand2(receiver), invoker : CommandPattern.Invoker = new CommandPattern.Invoker(); invoker.storeAndExecute(command1); invoker.storeAndExecute(command2);&#125;()); 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Behavioral Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>命令模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式(Adapter)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FAdapter%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 适配器模式的定义 适配器模式：用于将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 适配器模式包含四个角色： Target：目标抽象类-定义客户要用的特定领域的接口 Adapter：适配器类-作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心 Adaptee：适配者类-定义了一个已经存在的接口，这个接口需要适配 Client：客户类-在客户类中针对目标抽象类（Target）进行编程，调用在目标抽象类中定义的业务方法 ES6实现1234567891011121314151617181920212223242526272829303132333435363738394041424344class Target &#123; constructor(type) &#123; console.log('Target Class created!'); let result = undefined; switch (type) &#123; case 'adapter': result = new AdapterImpl(); break default: result = undefined; &#125; return result; &#125; request() &#123; console.log('Target.request invoked'); &#125;&#125;class Adapter &#123; constructor() &#123; console.log('Adapter Class created'); &#125; specificRequest() &#123; console.log('Adapter.specificRequest invoked'); &#125;&#125;class AdapterImpl extends Adapter &#123; constructor() &#123; super() console.log('AdapterImpl Class created'); &#125; request() &#123; console.log('AdapterImpl.request invoked'); return this.specificRequest(); &#125;&#125;var f = new Target("adapter");f.request(); Typescript实现12345678910111213141516171819namespace AdapterPattern &#123; export class Adaptee &#123; public method(): void &#123; console.log("`method` of Adaptee is being called"); &#125; &#125; export interface Target &#123; call(): void; &#125; export class Adapter implements Target &#123; public call(): void &#123; console.log("Adapter's `call` method is being called"); var adaptee: Adaptee = new Adaptee(); adaptee.method(); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Structural Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中介模式(Mediator)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FMediator%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 中介模式的定义 中介者模式用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信； 在具体同事类中实现了在抽象同事类中定义的方法。 中介者模式又称为调停者模式，它是一种对象行为型模式。中介模式包含二个角色： Mediator-抽象中介者用于定义一个接口，该接口用于与各同事对象之间的通信； ConcreteMediator-具体中介者是抽象中介者的子类，通过协调各个同事对象来实现协作行为，了解并维护它的各个同事对象的引用； Colleague-抽象同事类定义各同事的公有方法； Colleague-具体同事类是抽象同事类的子类，每一个同事对象都引用一个中介者对象； ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class Mediator &#123; constructor() &#123; console.log('Mediator Class created'); &#125; colleagueChanged(colleague) &#123; console.log('Mediator.colleagueChanged invoked'); &#125;&#125;class ConcreteMediator extends Mediator &#123; constructor() &#123; super(); console.log('ConcreteMediator Class created'); this.colleague1 = new ConcreteColleague1(this); this.colleague2 = new ConcreteColleague2(this); &#125; colleagueChanged(colleague) &#123; console.log('ConcreteMediator.colleagueChanged invoked'); switch (colleague) &#123; case this.colleague1: console.log('ConcreteColleague1 has Changed -&gt; change ConcreteColleague2.feature: '); this.colleague2.setFeature('new feature 2'); break case this.colleague2: console.log('ConcreteColleague2 has Changed, but do nothing'); break default: console.log('Do nothing'); &#125; &#125;&#125;class Colleague &#123; constructor() &#123; console.log('Colleague Class created'); &#125; changed() &#123; console.log('Colleague.changed invoked'); this.mediator.colleagueChanged(this); &#125;&#125;class ConcreteColleague1 extends Colleague &#123; constructor(mediator) &#123; super(); console.log('ConcreteColleague1 Class created'); this.mediator = mediator; this.feature = "feature 1"; &#125; setFeature(feature) &#123; console.log('ConcreteColleague1.setFeature invoked'); console.log('ConcreteColleague1 Feature has changed from ' + this.feature + ' to ' + feature) this.feature = feature; this.changed(); &#125;&#125;class ConcreteColleague2 extends Colleague &#123; constructor(mediator) &#123; super(); console.log('ConcreteColleague2 Class created'); this.mediator = mediator; this.feature = "feature 2"; &#125; setFeature(feature) &#123; console.log('ConcreteColleague2.setFeature invoked'); console.log('ConcreteColleague2 Feature has changed from ' + this.feature + ' to ' + feature); this.feature = feature; this.changed(); &#125;&#125;var mediator = new ConcreteMediator();mediator.colleague1.setFeature("new feature 1"); Typescript实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162namespace MediatorPattern &#123; export interface Mediator &#123; send(msg: string, colleague: Colleague): void; &#125; export class Colleague &#123; public mediator: Mediator; constructor(mediator: Mediator) &#123; this.mediator = mediator; &#125; public send(msg: string): void &#123; throw new Error("Abstract Method!"); &#125; public receive(msg: string): void &#123; throw new Error("Abstract Method!"); &#125; &#125; export class ConcreteColleagueA extends Colleague &#123; constructor(mediator: Mediator) &#123; super(mediator); &#125; public send(msg: string): void &#123; this.mediator.send(msg, this); &#125; public receive(msg: string): void &#123; console.log(msg, "`receive` of ConcreteColleagueA is being called!"); &#125; &#125; export class ConcreteColleagueB extends Colleague &#123; constructor(mediator: Mediator) &#123; super(mediator); &#125; public send(msg: string): void &#123; this.mediator.send(msg, this); &#125; public receive(msg: string): void &#123; console.log(msg, "`receive` of ConcreteColleagueB is being called!"); &#125; &#125; export class ConcreteMediator implements Mediator &#123; public concreteColleagueA: ConcreteColleagueA; public concreteColleagueB: ConcreteColleagueB; public send(msg: string, colleague: Colleague): void &#123; if (this.concreteColleagueA === colleague) &#123; this.concreteColleagueB.receive(msg); &#125; else &#123; this.concreteColleagueA.receive(msg); &#125; &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>Behavioral Patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>中介模式</tag>
      </tags>
  </entry>
</search>