<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[适配器模式(Adapter)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FAdapter%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 适配器模式的定义 适配器模式：用于将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 适配器模式包含四个角色： Target：目标抽象类-定义客户要用的特定领域的接口 Adapter：适配器类-作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心 Adaptee：适配者类-定义了一个已经存在的接口，这个接口需要适配 Client：客户类-在客户类中针对目标抽象类（Target）进行编程，调用在目标抽象类中定义的业务方法 ES6实现1234567891011121314151617181920212223242526272829303132333435363738394041424344class Target &#123; constructor(type) &#123; console.log('Target Class created!'); let result = undefined; switch (type) &#123; case 'adapter': result = new AdapterImpl(); break default: result = undefined; &#125; return result; &#125; request() &#123; console.log('Target.request invoked'); &#125;&#125;class Adapter &#123; constructor() &#123; console.log('Adapter Class created'); &#125; specificRequest() &#123; console.log('Adapter.specificRequest invoked'); &#125;&#125;class AdapterImpl extends Adapter &#123; constructor() &#123; super() console.log('AdapterImpl Class created'); &#125; request() &#123; console.log('AdapterImpl.request invoked'); return this.specificRequest(); &#125;&#125;var f = new Target("adapter");f.request(); Typescript实现12345678910111213141516171819namespace AdapterPattern &#123; export class Adaptee &#123; public method(): void &#123; console.log("`method` of Adaptee is being called"); &#125; &#125; export interface Target &#123; call(): void; &#125; export class Adapter implements Target &#123; public call(): void &#123; console.log("Adapter's `call` method is being called"); var adaptee: Adaptee = new Adaptee(); adaptee.method(); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>structural-patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桥接模式(Bridge)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FBridge%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 桥接模式的定义 桥接模式：模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。 桥接模式包含四个角色： Abstraction-抽象类中定义了一个实现类接口类型的对象并可以维护该对象； RefinedAbstraction-扩充抽象类扩充由抽象类定义的接口，它实现了在抽象类中定义的抽象业务方法，在扩充抽象类中可以调用在实现类接口中定义的业务方法； Implementor实现类接口定义了实现类的接口，实现类接口仅提供基本操作，而抽象类定义的接口可能会做更多更复杂的操作； ConcreteImplementor具体实现类实现了实现类接口并且具体实现它，在不同的具体实现类中提供基本操作的不同实现，在程序运行时，具体实现类对象将替换其父类对象，提供给客户端具体的业务操作方法。 ES6实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Abstraction &#123; constructor() &#123; console.log('Abstraction Class created'); &#125; operation() &#123; console.log('Abstraction.operation invoked'); this.imp.operationImp(); &#125;&#125;class RefinedAbstraction extends Abstraction &#123; constructor() &#123; super() console.log('RefinedAbstraction Class created'); &#125; setImp(imp) &#123; console.log('RefinedAbstraction.setImp invoked'); this.imp = imp &#125;&#125;class Implementor &#123; constructor() &#123; console.log('Implementor Class created'); &#125; operationImp() &#123; console.log('Implementor.operationImp invoked'); &#125;&#125;class ConcreteImplementorA extends Implementor &#123; constructor() &#123; super() console.log('ConcreteImplementorA Class created'); &#125; operationImp() &#123; console.log('ConcreteImplementorA.operationImp invoked'); &#125;&#125;class ConcreteImplementorB extends Implementor &#123; constructor() &#123; super() console.log('ConcreteImplementorB Class created'); &#125; operationImp() &#123; console.log('ConcreteImplementorB.operationImp invoked'); &#125;&#125;var abstraction = new RefinedAbstraction();abstraction.setImp(new ConcreteImplementorA());abstraction.operation();abstraction.setImp(new ConcreteImplementorB());abstraction.operation(); Typescript实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Abstraction &#123; constructor() &#123; console.log('Abstraction Class created'); &#125; operation() &#123; console.log('Abstraction.operation invoked'); this.imp.operationImp(); &#125;&#125;class RefinedAbstraction extends Abstraction &#123; constructor() &#123; super() console.log('RefinedAbstraction Class created'); &#125; setImp(imp) &#123; console.log('RefinedAbstraction.setImp invoked'); this.imp = imp &#125;&#125;class Implementor &#123; constructor() &#123; console.log('Implementor Class created'); &#125; operationImp() &#123; console.log('Implementor.operationImp invoked'); &#125;&#125;class ConcreteImplementorA extends Implementor &#123; constructor() &#123; super() console.log('ConcreteImplementorA Class created'); &#125; operationImp() &#123; console.log('ConcreteImplementorA.operationImp invoked'); &#125;&#125;class ConcreteImplementorB extends Implementor &#123; constructor() &#123; super() console.log('ConcreteImplementorB Class created'); &#125; operationImp() &#123; console.log('ConcreteImplementorB.operationImp invoked'); &#125;&#125;var abstraction = new RefinedAbstraction();abstraction.setImp(new ConcreteImplementorA());abstraction.operation();abstraction.setImp(new ConcreteImplementorB());abstraction.operation(); 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>structural-patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>桥接模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者模式(Builder)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FBuilder%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 建造者模式包含如下四个角色： Builder-抽象建造者为创建一个产品对象的各个部件指定抽象接口； ConcreteBuilder-具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象； Product-产品角色是被构建的复杂对象，包含多个组成部件； Director-指挥者负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造 建造者模式的结构中引入了一个指挥者类，该类的作用主要有两个： 一方面它隔离了客户与生产过程； 另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。 ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Builder &#123; constructor() &#123; console.log('Builder Class created!'); &#125; buildPart(partName) &#123; console.log('Builder.buildPart invoked!'); &#125;&#125;class ConcreteBuilder extends Builder &#123; constructor() &#123; super(); console.log('ConcreteBuilder Class created!'); &#125; buildPart(partName) &#123; super.buildPart(partName); console.log('ConcreteBuilder.buildPart invoked!'); this.product = new Product(partName); &#125; getResult() &#123; console.log('ConcreteBuilder.getResult invoked!'); return this.product; &#125;&#125;class Product &#123; constructor(material) &#123; console.log("Product class created"); this.data = material &#125;&#125;class Director &#123; constructor() &#123; this.structure = ['Prod1', 'Prod2', 'Prod3']; console.log("Director class created"); &#125; construct() &#123; console.log("Director.Construct created"); for (var prodName in this.structure) &#123; let builder = new ConcreteBuilder(); builder.buildPart(this.structure[prodName]); builder.getResult(); &#125; &#125;&#125;let director = new Director();director.construct(); Typescript实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869namespace BuilderPattern &#123; export class UserBuilder &#123; private name: string; private age: number; private phone: string; private address: string; constructor(name: string) &#123; this.name = name; &#125; get Name() &#123; return this.name; &#125; setAge(value: number): UserBuilder &#123; this.age = value; return this; &#125; get Age() &#123; return this.age; &#125; setPhone(value: string): UserBuilder &#123; this.phone = value; return this; &#125; get Phone() &#123; return this.phone; &#125; setAddress(value: string): UserBuilder &#123; this.address = value; return this; &#125; get Address() &#123; return this.address; &#125; build(): User &#123; return new User(this); &#125; &#125; export class User &#123; private name: string; private age: number; private phone: string; private address: string; constructor(builder: UserBuilder) &#123; this.name = builder.Name; this.age = builder.Age; this.phone = builder.Phone; this.address = builder.Address &#125; get Name() &#123; return this.name; &#125; get Age() &#123; return this.age; &#125; get Phone() &#123; return this.phone; &#125; get Address() &#123; return this.address; &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>creational-patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>建造者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合模式(Composite)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FComposite%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 ES6实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Component &#123; constructor() &#123; console.log('Component Class created'); &#125; operation() &#123; console.log('Component.operation invoked'); &#125; add(Component) &#123; console.log('Component.add invoked'); &#125; remove(Component) &#123; console.log('Component.remove invoked'); &#125; getChild(key) &#123; console.log('Component.getChild invoked'); &#125;&#125;class Leaf extends Component &#123; constructor(name) &#123; super(); this.name = name; console.log('Leaf Class created'); &#125; operation() &#123; console.log('Leaf.operation invoked'); console.log(this.name); &#125;&#125;class Composite extends Component &#123; constructor(name) &#123; super(); this.name = name; this.children = []; console.log('Composite Class created'); &#125; operation() &#123; console.log('Composite operation for: ' + this.name) for (var i in this.children) &#123; this.children[i].operation(); &#125; &#125; add(Component) &#123; console.log('Composite.add invoked'); this.children.push(Component); &#125; remove(Component) &#123; console.log('Composite.remove invoked'); for (var i in this.children) &#123; if (this.children[i] === Component) &#123; this.children.splice(i, 1); &#125; &#125; &#125; getChild(key) &#123; console.log('Composite.getChild invoked'); return this.children[key]; &#125;&#125;var composite1 = new Composite('C1');composite1.add(new Leaf('L1'));composite1.add(new Leaf('L2'));var composite2 = new Composite('C2');composite2.add(composite1);composite1.getChild(1).operation();composite2.operation(); Typescript实现1234567891011121314151617181920212223242526272829303132333435363738394041424344namespace CompositePattern &#123; export interface Component &#123; operation(): void; &#125; export class Composite implements Component &#123; private list: Component[]; private s: String; constructor(s: String) &#123; this.list = []; this.s = s; &#125; public operation(): void &#123; console.log("`operation of `", this.s) for (var i = 0; i &lt; this.list.length; i += 1) &#123; this.list[i].operation(); &#125; &#125; public add(c: Component): void &#123; this.list.push(c); &#125; public remove(i: number): void &#123; if (this.list.length &lt;= i) &#123; throw new Error("index out of bound!"); &#125; this.list.splice(i, 1); &#125; &#125; export class Leaf implements Component &#123; private s: String; constructor(s: String) &#123; this.s = s; &#125; public operation(): void &#123; console.log("`operation` of Leaf", this.s, " is called."); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>structural-patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式(Abstract Factory)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FAbstractFactory%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 抽象工厂模式的定义 抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。 抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构 抽象工厂模式包含四个角色： ConcreteFactory-具体工厂实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中； AbstractProduct-抽象产品为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法； AbstractFactory-抽象工厂用于明生成抽象产品的方法； Product-具体产品定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。 抽象工厂模式适用情况包括： 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节； 系统中有多于一个的产品族，而每次只使用其中某一产品族； 属于同一个产品族的产品将在一起使用； 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。 ES6实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495class AbstractFactory &#123; constructor() &#123; console.log("AbstractFactory class created"); &#125; createProductA(product) &#123; console.log("AbstractFactory.createProductA created"); &#125; createProductB(product) &#123; console.log("AbstractFactory.createProductB created"); &#125;&#125;class ConcreteFactory1 extends AbstractFactory &#123; constructor() &#123; super(); console.log("ConcreteFactory1 class created"); &#125; createProductA(product) &#123; console.log('ConcreteFactory1 createProductA'); return new ProductA1(); &#125; createProductB(product) &#123; console.log('ConcreteFactory1 createProductB'); return new ProductB1(); &#125;&#125;class ConcreteFactory2 extends AbstractFactory &#123; constructor() &#123; super(); console.log("ConcreteFactory2 class created"); &#125; createProductA(product) &#123; console.log('ConcreteFactory2 createProductA'); return new ProductA2(); &#125; createProductB(product) &#123; console.log('ConcreteFactory2 createProductB'); return new ProductB2(); &#125;&#125;class AbstractProductA &#123; constructor() &#123; console.log('AbstractProductA class created'); &#125;&#125;class AbstractProductB &#123; constructor() &#123; console.log('AbstractProductB class created'); &#125;&#125;class ProductA1 extends AbstractProductA &#123; constructor() &#123; super(); console.log('ProductA1 class created'); &#125;&#125;class ProductA2 extends AbstractProductA &#123; constructor() &#123; super(); console.log('ProductA2 class created'); &#125;&#125;class ProductB1 extends AbstractProductB &#123; constructor() &#123; super(); console.log('ProductB1 class created'); &#125;&#125;class ProductB2 extends AbstractProductB &#123; constructor() &#123; super(); console.log('ProductB2 class created'); &#125;&#125;var factory1 = new ConcreteFactory1();var productB1 = factory1.createProductB();var productA1 = factory1.createProductA();var factory2 = new ConcreteFactory2();var productA2 = factory2.createProductA();var productB2 = factory2.createProductB(); Typescript实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273namespace AbstractFactoryPattern &#123; export interface AbstractProductA &#123; methodA(): string; &#125; export interface AbstractProductB &#123; methodB(): number; &#125; export interface AbstractFactory &#123; createProductA(param?: any) : AbstractProductA; createProductB() : AbstractProductB; &#125; export class ProductA1 implements AbstractProductA &#123; methodA = () =&gt; &#123; return "This is methodA of ProductA1"; &#125; &#125; export class ProductB1 implements AbstractProductB &#123; methodB = () =&gt; &#123; return 1; &#125; &#125; export class ProductA2 implements AbstractProductA &#123; methodA = () =&gt; &#123; return "This is methodA of ProductA2"; &#125; &#125; export class ProductB2 implements AbstractProductB &#123; methodB = () =&gt; &#123; return 2; &#125; &#125; export class ConcreteFactory1 implements AbstractFactory &#123; createProductA(param?: any) : AbstractProductA &#123; return new ProductA1(); &#125; createProductB(param?: any) : AbstractProductB &#123; return new ProductB1(); &#125; &#125; export class ConcreteFactory2 implements AbstractFactory &#123; createProductA(param?: any) : AbstractProductA &#123; return new ProductA2(); &#125; createProductB(param?: any) : AbstractProductB &#123; return new ProductB2(); &#125; &#125; export class Tester &#123; private abstractProductA: AbstractProductA; private abstractProductB: AbstractProductB; constructor(factory: AbstractFactory) &#123; this.abstractProductA = factory.createProductA(); this.abstractProductB = factory.createProductB(); &#125; public test(): void &#123; console.log(this.abstractProductA.methodA()); console.log(this.abstractProductB.methodB()); &#125; &#125; &#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>creational-patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰模式(Decorator)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FDecorator%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 装饰模式的定义 装饰模式：装饰模式用于动态地给一个对象增加一些额外的职责，就增加对象功 能来说，装饰模式比生成子类实现更为灵活。它是一种对象结构型模 式。 装饰模式包含四个角色： Component-抽象构件定义了对象的接口，可以给这些对 象动态增加职责（方法）； ConcreteComponent-具体构件定义了具体的构件对象，实现了 在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）； Decorator-抽象装饰类是抽象构件类的子类，用于给具体构件增加职责，但是具 体职责在其子类中实现； ConcreteDecorator-具体装饰类是抽象装饰类的子类，负责向构 件添加新的职责。 ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Component &#123; constructor() &#123; console.log('Component Class created'); &#125; operation() &#123; console.log('Component.operation invoked'); &#125;&#125;class ConcreteComponent extends Component &#123; constructor() &#123; super(); console.log('ConcreteComponent Class created'); &#125; operation() &#123; console.log('ConcreteComponent.operation invoked'); &#125;&#125;class Decorator extends Component &#123; constructor(component) &#123; super(); this.component = component; console.log('Decorator Class created'); &#125; operation() &#123; console.log('Decorator.operation invoked'); this.component.operation() &#125;&#125;class ConcreteDecoratorA extends Decorator &#123; constructor(component, sign) &#123; super(component); this.addedState = sign; console.log('ConcreteDecoratorA Class created'); &#125; operation() &#123; super.operation(); console.log('ConcreteDecoratorA.operation invoked'); console.log(this.addedState) &#125;&#125;class ConcreteDecoratorB extends Decorator &#123; constructor(component, sign) &#123; super(component); this.addedState = sign; console.log('ConcreteDecoratorB Class created'); &#125; operation() &#123; super.operation(); console.log('ConcreteDecoratorB.operation invoked'); console.log(this.addedState + this.addedState + this.addedState + this.addedState + this.addedState); &#125; addedBehavior() &#123; this.operation(); console.log('ConcreteDecoratorB.operation invoked'); &#125;&#125;var component = new ConcreteComponent();var decoratorA = new ConcreteDecoratorA(component, 'decoratorA');var decoratorB = new ConcreteDecoratorB(component, 'decoratorB');console.log('component: ');component.operation();console.log('decoratorA: ');decoratorA.operation();console.log('decoratorB: ');decoratorB.addedBehavior(); Typescript实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748namespace DecoratorPattern &#123; export interface Component &#123; operation(): void; &#125; export class ConcreteComponent implements Component &#123; private s: String; constructor(s: String) &#123; this.s = s; &#125; public operation(): void &#123; console.log("`operation` of ConcreteComponent", this.s, " is being called!"); &#125; &#125; export class Decorator implements Component &#123; private component: Component; private id: Number; constructor(id: Number, component: Component) &#123; this.id = id; this.component = component; &#125; public get Id(): Number &#123; return this.id; &#125; public operation(): void &#123; console.log("`operation` of Decorator", this.id, " is being called!"); this.component.operation(); &#125; &#125; export class ConcreteDecorator extends Decorator &#123; constructor(id: Number, component: Component) &#123; super(id, component); &#125; public operation(): void &#123; super.operation(); console.log("`operation` of ConcreteDecorator", this.Id, " is being called!"); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>structural-patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>装饰模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式(Prototype)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FProrotype%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Prototype &#123; constructor(prototype) &#123; console.log("Prototype Class created"); &#125; setFeature(key, val) &#123; this[key] = val &#125; clone() &#123; console.log("Prototype.clone invoked"); &#125;&#125;class ConcretePrototype1 extends Prototype &#123; constructor() &#123; super(); console.log("ConcretePrototype1 created"); this.feature = "feature 1" &#125; clone() &#123; console.log('ConcretePrototype1.clone invoked'); let clone = new ConcretePrototype1(); let keys = Object.keys(this); keys.forEach(k =&gt; clone.setFeature(k, this[k])); console.log("ConcretePrototype1 cloned"); return clone; &#125;&#125;class ConcretePrototype2 extends Prototype &#123; constructor() &#123; super(); console.log("ConcretePrototype2 created"); this.feature = "feature 2" &#125; clone() &#123; console.log('ConcretePrototype2.Clone function'); let clone = new ConcretePrototype2(); let keys = Object.keys(this); keys.forEach(k =&gt; clone.setFeature(k, this[k])); console.log("ConcretePrototype2 cloned"); return clone; &#125;&#125;var proto1 = new ConcretePrototype1();proto1.setFeature('feature', "feature 11");var clone1 = proto1.clone();console.log(clone1.feature);console.log(typeof clone1);console.log(clone1 === proto1);var proto2 = new ConcretePrototype2();proto2.setFeature('feature', "feature 22");var clone2 = proto2.clone();console.log(clone2.feature);console.log(typeof clone2);console.log(clone2 === proto2); Typescript实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455namespace PrototypePattern &#123; export interface Prototype &#123; clone(): Prototype; toString(): string; &#125; export class Concrete1 implements Prototype &#123; clone() : Prototype &#123; return new Concrete1(); &#125; toString(): string &#123; return "This is Concrete1"; &#125; &#125; export class Concrete2 implements Prototype &#123; clone() : Prototype &#123; return new Concrete2(); &#125; toString(): string &#123; return "This is Concrete2"; &#125; &#125; export class Concrete3 implements Prototype &#123; clone() : Prototype &#123; return new Concrete3(); &#125; toString(): string &#123; return "This is Concrete3"; &#125; &#125; export class Builder &#123; private prototypeMap: &#123; [s: string]: Prototype; &#125; = &#123;&#125;; constructor() &#123; this.prototypeMap['c1'] = new Concrete1(); this.prototypeMap['c2'] = new Concrete2(); this.prototypeMap['c3'] = new Concrete3(); &#125; createOne(s: string): Prototype &#123; console.log(s); return this.prototypeMap[s].clone(); &#125; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>creational-patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单工厂模式(Factory)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FSimpleFactory%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 简单工厂模式的定义 简单工厂模式：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。 简单工厂模式包含三个角色： Factory-工厂角色负责实现创建所有实例的内部逻辑； Product-抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口； ConcreteProduct-具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。 ES6实现12345678910111213141516171819202122232425262728293031323334353637383940414243class Product &#123; constructor() &#123; console.log('Product Class created'); &#125;&#125;class ConcreteProduct extends Product &#123; constructor() &#123; super(); console.log('ConcreteProduct Class created'); &#125;&#125;class Creator &#123; constructor() &#123; console.log('Creator Class created'); &#125; factoryMethod() &#123; console.log('Creator.factoryMethod created'); &#125; anOperation() &#123; console.log('Creator.anOperation created'); this.product = this.factoryMethod(); console.log(this.product instanceof ConcreteProduct); &#125;&#125;class ConcreteCreator extends Creator &#123; constructor() &#123; super(); console.log('ConcreteCreator Class created'); &#125; factoryMethod() &#123; return new ConcreteProduct(); &#125;&#125;var factory = new ConcreteCreator();factory.anOperation(); Typescript实现123456789101112131415161718192021222324252627interface AbstractProduct &#123; method(param?: any) : void;&#125;class ConcreteProductA implements AbstractProduct &#123; method = (param?: any) =&gt; &#123; return "Method of ConcreteProductA"; &#125;&#125;class ConcreteProductB implements AbstractProduct &#123; method = (param?: any) =&gt; &#123; return "Method of ConcreteProductB"; &#125;&#125;class ProductFactory &#123; public static createProduct(type: string) : AbstractProduct &#123; if (type === "A") &#123; return new ConcreteProductA(); &#125; else if (type === "B") &#123; return new ConcreteProductB(); &#125; return null; &#125;&#125; 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>creational-patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式(Singleton)-设计模式]]></title>
    <url>%2F2017%2F05%2F05%2FSingleton%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 单例模式的定义 某个类只能有一个实例； 它必须自行创建这个实例； 它必须自行向整个系统提供这个实例。 单例模式的实现过程中，需要注意如下三点： 单例类的构造函数为私有； 提供一个自身的静态私有成员变量； 提供一个公有的静态工厂方法。 ES6实现1234567891011121314class Singleton &#123; constructor(data) &#123; if (Singleton.prototype.Instance === undefined) &#123; this.data = data; Singleton.prototype.Instance = this; &#125; return Singleton.prototype.Instance; &#125;&#125;let ob1 = new Singleton.getInstance();let ob2 = new Singleton("two");console.log(ob1 === ob2); Typescript实现12345678910111213141516class Singleton &#123; private static instance: Singleton; constructor() &#123;&#125; static get Instance() &#123; if (this.instance === null || this.instance === undefined) &#123; this.instance = new Singleton(); &#125; return this.instance; &#125;&#125;let ob1 = new Singleton("one");let ob2 = new Singleton("two");console.log(ob1 === ob2); 参考以下内容: 图说设计模式 ECMAScript2016-Design-Patterns Design Patterns in TypeScript]]></content>
      <categories>
        <category>design-pattern</category>
        <category>creational-patterns</category>
      </categories>
      <tags>
        <tag>javasctipt</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
</search>